import 'dart:async';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import 'package:geolocator/geolocator.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../../core/models/post/post_model.dart';
import '../../../core/models/user/user_model.dart';  // UserModel과 UserType 추가
import '../../../core/services/data/post_service.dart';
import '../../../core/services/data/marker_service.dart';  // MarkerService 추가
import '../../../core/services/data/user_service.dart';  // UserService 추가
import '../../../core/constants/app_constants.dart';
import '../services/markers/marker_service.dart';
import '../../../core/models/marker/marker_model.dart';
import 'package:latlong2/latlong.dart';
import '../widgets/marker_layer_widget.dart';
import '../utils/client_cluster.dart';
import '../widgets/cluster_widgets.dart';
import '../../post_system/controllers/post_deployment_controller.dart';
import '../../../core/services/osm_geocoding_service.dart';
import '../../post_system/widgets/address_search_dialog.dart';
// OSM 기반 Fog of War 시스템
import '../services/external/osm_fog_service.dart';
import '../services/fog_of_war/visit_tile_service.dart';
import '../widgets/unified_fog_overlay_widget.dart';
import '../../../core/services/location/nominatim_service.dart';
import '../../../core/services/location/location_service.dart';
import '../../../utils/tile_utils.dart';
import '../../../core/models/map/fog_level.dart';
import '../models/receipt_item.dart';
import '../widgets/receive_carousel.dart';
import 'package:vibration/vibration.dart';
import 'package:audioplayers/audioplayers.dart' as audio;

/// 마커 아이템 클래스
class MarkerItem {
  final String id;
  final String title;
  final String price;
  final String amount;
  final String userId;
  final Map<String, dynamic> data;
  final LatLng position;
  final String? imageUrl;
  final int remainingAmount;
  final DateTime? expiryDate;

  MarkerItem({
    required this.id,
    required this.title,
    required this.price,
    required this.amount,
    required this.userId,
    required this.data,
    required this.position,
    this.imageUrl,
    required this.remainingAmount,
    this.expiryDate,
  });
}

class MapScreen extends StatefulWidget {
  final Function(String)? onAddressChanged;
  final VoidCallback? onNavigateToInbox;
  
  const MapScreen({super.key, this.onAddressChanged, this.onNavigateToInbox});
  static final GlobalKey<_MapScreenState> mapKey = GlobalKey<_MapScreenState>();

  @override
  _MapScreenState createState() => _MapScreenState();
}

class _MapScreenState extends State<MapScreen> {
  // OSM 기반 Fog of War 상태
  List<Polygon> _grayPolygons = []; // 회색 영역들 (과거 방문 위치)
  List<CircleMarker> _ringCircles = [];
  List<Marker> _currentMarkers = [];
  
  // 클러스터링 관련 변수들
  List<Marker> _clusteredMarkers = [];
  Size _lastMapSize = const Size(0, 0);
  LatLng _mapCenter = const LatLng(37.5665, 126.9780); // 서울 기본값
  double _mapZoom = 10.0;
  
  // 새로운 클러스터링 시스템용 변수들
  Timer? _clusterDebounceTimer;
  List<ClusterMarkerModel> _visibleMarkerModels = [];
  
  // 사용자 위치 정보
  LatLng? _homeLocation;
  List<LatLng> _workLocations = [];
  
  // 기본 상태
  MapController? _mapController;
  LatLng? _currentPosition;
  double _currentZoom = 14.0;
  String _currentAddress = '위치 불러오는 중...';
  LatLng? _longPressedLatLng;
  Widget? _customMarkerIcon;
  
  
  // 포스트 관련
  List<PostModel> _posts = [];
  List<MarkerModel> _markers = []; // 새로운 마커 모델 사용
  bool _isLoading = false;
  String? _errorMessage;
  
  // 필터 관련
  bool _showFilter = false;
  String _selectedCategory = 'all';
  double _maxDistance = 1000.0; // 기본 1km, 유료회원 3km
  int _minReward = 0;
  bool _showCouponsOnly = false;
  bool _showMyPostsOnly = false;
  bool _showUrgentOnly = false; // 마감임박 필터 추가
  bool _showVerifiedOnly = false; // 인증 포스트만 필터 추가
  bool _showUnverifiedOnly = false; // 미인증 포스트만 필터 추가
  bool _isPremiumUser = false; // 유료 사용자 여부
  UserType _userType = UserType.normal; // 사용자 타입 추가
  
  // 실시간 업데이트 관련
  Timer? _mapMoveTimer;
  LatLng? _lastMapCenter;
  Set<String> _lastFogLevel1Tiles = {};
  bool _isUpdatingPosts = false;

  // 포스트 수령 관련
  int _receivablePostCount = 0;
  bool _isReceiving = false;
  String? _lastCacheKey; // 캐시 키 기반 스킵용
  
  // 로컬 포그레벨 1 타일 캐시 (즉시 반영용)
  Set<String> _currentFogLevel1TileIds = {};
  DateTime? _fogLevel1CacheTimestamp;
  static const Duration _fogLevel1CacheExpiry = Duration(minutes: 5); // 5분 후 캐시 만료
  
  // 포그레벨 변경 감지 관련
  Map<String, int> _tileFogLevels = {}; // 타일별 포그레벨 캐시
  Set<String> _visiblePostIds = {}; // 현재 표시 중인 포스트 ID들
  
  
  // 클러스터링 관련
  bool _isClustered = false;
  static const double _clusterRadius = 50.0; // 픽셀 단위
  
  // 위치 이동 관련
  int _currentWorkplaceIndex = 0; // 현재 일터 인덱스
  
  // Mock 위치 관련 상태
  bool _isMockModeEnabled = false;
  bool _isMockControllerVisible = false;
  LatLng? _mockPosition;
  LatLng? _originalGpsPosition; // 원래 GPS 위치 백업
  LatLng? _previousMockPosition; // 이전 Mock 위치 (회색 영역 표시용)
  LatLng? _previousGpsPosition; // 이전 GPS 위치 (회색 영역 표시용)
  
  // ✅ 일터 리스너 구독 관리 (중복 방지)
  StreamSubscription<DocumentSnapshot>? _workplaceSubscription;

  @override
  void initState() {
    super.initState();
    _mapController = MapController();
    
    _initializeLocation();
    _loadCustomMarker();
    _loadUserLocations();
    _setupUserDataListener();
    _setupMarkerListener();
    _updateReceivablePosts(); // 수령 가능 포스트 개수 초기화
    // _checkPremiumStatus()와 _setupPostStreamListener()는 _getCurrentLocation()에서 호출됨
    
  }

  void _setupUserDataListener() {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      print('사용자 데이터 리스너 설정 실패: 사용자가 로그인하지 않음');
      return;
    }

    print('사용자 데이터 리스너 설정 시작: ${user.uid}');

    // 사용자 데이터 변경을 실시간으로 감지
    FirebaseFirestore.instance
        .collection('users')
        .doc(user.uid)
        .snapshots()
        .listen((snapshot) {
      if (snapshot.exists) {
        print('사용자 데이터 변경 감지됨 - 타임스탬프: ${DateTime.now()}');
        final data = snapshot.data();
        if (data != null) {
          final workplaces = data['workplaces'] as List<dynamic>?;
          print('변경된 근무지 개수: ${workplaces?.length ?? 0}');
          
          // 사용자 타입 로드
          final userModel = UserModel.fromFirestore(snapshot);
          if (mounted) {
            setState(() {
              _userType = userModel.userType;
              _isPremiumUser = userModel.userType == UserType.superSite;
            });
          }
          
          // ✅ 일터 변경 감지를 위한 리스너 설정
          final workplaceId = data['workplaceId'] as String?;
          if (workplaceId != null && workplaceId.isNotEmpty) {
            _setupWorkplaceListener(workplaceId);
          }
        }
        _loadUserLocations();
      } else {
        print('사용자 데이터가 존재하지 않음');
      }
    }, onError: (error) {
      print('사용자 데이터 리스너 오류: $error');
    });
  }

  // ✅ 일터(Place) 변경사항 실시간 감지 리스너
  void _setupWorkplaceListener(String workplaceId) {
    print('💼 일터 리스너 설정 시작: $workplaceId');
    
    // ✅ 기존 리스너 취소 (중복 방지)
    _workplaceSubscription?.cancel();
    
    // ✅ 새로운 리스너 설정
    _workplaceSubscription = FirebaseFirestore.instance
        .collection('places')
        .doc(workplaceId)
        .snapshots()
        .listen((snapshot) {
      if (snapshot.exists) {
        print('💼 일터 정보 변경 감지됨 - 타임스탬프: ${DateTime.now()}');
        final data = snapshot.data();
        if (data != null) {
          final location = data['location'] as GeoPoint?;
          print('💼 변경된 일터 좌표: ${location?.latitude}, ${location?.longitude}');
          
          // 일터 위치 정보 새로고침
          _loadUserLocations();
        }
      }
    }, onError: (error) {
      print('❌ 일터 리스너 오류: $error');
    });
  }

  void _setupMarkerListener() {
    if (_currentPosition == null) return;

    print('마커 리스너 설정 시작');
  }


  // 유료 사용자 상태 확인
  Future<void> _checkPremiumStatus() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .get();

      if (userDoc.exists) {
        final userData = userDoc.data();
        final isPremium = userData?['isPremium'] ?? false;

        if (mounted) {
          setState(() {
            _isPremiumUser = isPremium;
            _maxDistance = isPremium ? 3000.0 : 1000.0; // 유료: 3km, 무료: 1km
          });
        }

        print('💰 유료 사용자 상태: $_isPremiumUser, 검색 반경: ${_maxDistance}m');
      }
    } catch (e) {
      print('유료 사용자 상태 확인 실패: $e');
    }
  }


  // 🚀 마커 서비스 리스너 설정 (포스트 조회 제거)
  void _setupPostStreamListener() {
    if (_currentPosition == null) {
      print('❌ _setupPostStreamListener: _currentPosition이 null입니다');
      return;
    }

    print('🚀 마커 서비스 리스너 설정 시작');
    print('📍 현재 위치: ${_currentPosition!.latitude}, ${_currentPosition!.longitude}');
    print('💰 유료 사용자: $_isPremiumUser');
    print('📏 검색 반경: ${_maxDistance}m (${_maxDistance / 1000.0}km)');

    // 새로운 구조: MarkerService에서 직접 마커 조회
    _updatePostsBasedOnFogLevel();
  }

  void _loadCustomMarker() {
    _customMarkerIcon = Container(
      width: 40,
      height: 40,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(color: Colors.white, width: 2),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.3),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: ClipOval(
        child: Image.asset(
          'assets/images/ppam_work.png',
          width: 36,
          height: 36,
          fit: BoxFit.cover,
        ),
          ),
        );
      }

  Future<void> _initializeLocation() async {
    try {
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          if (mounted) {
            setState(() {
              _errorMessage = '위치 권한이 거부되었습니다.';
            });
          }
          return;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        if (mounted) {
          setState(() {
            _errorMessage = '위치 권한이 영구적으로 거부되었습니다. 설정에서 권한을 허용해주세요.';
          });
        }
        return;
      }

      await _getCurrentLocation();
    } catch (e) {
      if (mounted) {
        setState(() {
          _errorMessage = '위치를 가져오는 중 오류가 발생했습니다: $e';
        });
      }
    }
  }

  Future<void> _getCurrentLocation() async {
    // Mock 모드가 활성화되어 있으면 GPS 위치 요청하지 않음
    if (_isMockModeEnabled && _mockPosition != null) {
      print('🎭 Mock 모드 활성화 - GPS 위치 요청 스킵');
      return;
    }
    
    try {
      print('📍 현재 위치 요청 중...');
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10),
      );
      
      print('✅ 현재 위치 획득 성공: ${position.latitude}, ${position.longitude}');
      print('   - 정확도: ${position.accuracy}m');
      print('   - 고도: ${position.altitude}m');
      print('   - 속도: ${position.speed}m/s');
      
      final newPosition = LatLng(position.latitude, position.longitude);

      // 이전 GPS 위치 저장 (회색 영역 표시용)
      final previousGpsPosition = _currentPosition;

      if (mounted) {
        setState(() {
          _currentPosition = newPosition;
          _errorMessage = null;
        });
      }

      // OSM Fog of War 재구성
      _rebuildFogWithUserLocations(newPosition);
      
      // 주소 업데이트
      _updateCurrentAddress();
      
      // 타일 방문 기록 업데이트 (새로운 기능)
      final tileId = TileUtils.getKm1TileId(newPosition.latitude, newPosition.longitude);
      print('   - 타일 ID: $tileId');
      await VisitTileService.updateCurrentTileVisit(tileId);
      
      // 즉시 반영 (렌더링용 메모리 캐시)
      _setLevel1TileLocally(tileId);
      
      // 회색 영역 업데이트 (이전 위치 포함)
      _updateGrayAreasWithPreviousPosition(previousGpsPosition);
      
      // 유료 상태 확인 후 포스트 스트림 설정
      await _checkPremiumStatus();
      
      // 🚀 실시간 포스트 스트림 리스너 설정 (위치 확보 후)
      _setupPostStreamListener();
      
      // 추가로 마커 조회 강제 실행 (위치 기반으로 더 정확하게)
      print('🚀 위치 설정 완료 후 마커 조회 강제 실행');
      if (mounted) {
        setState(() {
          _isLoading = true;
        });
      }
      _updatePostsBasedOnFogLevel();
      
      // 현재 위치 마커 생성
      _createCurrentLocationMarker(newPosition);
      
      // 지도 중심 이동
      _mapController?.move(newPosition, _currentZoom);

    } catch (e) {
      if (mounted) {
        setState(() {
          _errorMessage = '현재 위치를 가져올 수 없습니다: $e';
        });
      }
    }
  }

  void _createCurrentLocationMarker(LatLng position) {
    final marker = Marker(
      point: position,
      width: 30,
      height: 30,
      child: Container(
          decoration: BoxDecoration(
            color: Colors.red,
            shape: BoxShape.circle,
            border: Border.all(color: Colors.white, width: 2),
          ),
          child: const Icon(
          Icons.my_location,
            color: Colors.white,
          size: 16,
        ),
      ),
        );

        if (mounted) {
          setState(() {
            _currentMarkers = [marker];
          });
        }
  }


  /// 모든 위치를 반환하는 메서드 (현재 위치, 집, 근무지)

  void _rebuildFogWithUserLocations(LatLng currentPosition) {
    final allPositions = <LatLng>[currentPosition];
    final ringCircles = <CircleMarker>[];

    print('포그 오브 워 재구성 시작');
    print('현재 위치: ${currentPosition.latitude}, ${currentPosition.longitude}');
    print('집 위치: ${_homeLocation?.latitude}, ${_homeLocation?.longitude}');
    print('근무지 개수: ${_workLocations.length}');

    // 현재 위치
    ringCircles.add(OSMFogService.createRingCircle(currentPosition));

    // 집 위치
    if (_homeLocation != null) {
      allPositions.add(_homeLocation!);
      ringCircles.add(OSMFogService.createRingCircle(_homeLocation!));
      print('집 위치 추가됨');
    }

    // 일터 위치들
    for (int i = 0; i < _workLocations.length; i++) {
      final workLocation = _workLocations[i];
      allPositions.add(workLocation);
      ringCircles.add(OSMFogService.createRingCircle(workLocation));
      print('근무지 $i 추가됨: ${workLocation.latitude}, ${workLocation.longitude}');
    }

    print('총 밝은 영역 개수: ${allPositions.length}');

    if (mounted) {
      setState(() {
        _ringCircles = ringCircles;
      });
    }

    print('포그 오브 워 재구성 완료');
  }

  Future<void> _loadUserLocations() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      // 사용자 프로필에서 집주소 가져오기
      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .get();

      if (userDoc.exists) {
        final userData = userDoc.data();

        // ===== 집 주소 로드 =====
        final homeLocation = userData?['homeLocation'] as GeoPoint?;
        final secondAddress = userData?['secondAddress'] as String?;

        if (homeLocation != null) {
          // 저장된 GeoPoint 직접 사용 (geocoding 불필요)
          debugPrint('✅ 집주소 좌표 로드: ${homeLocation.latitude}, ${homeLocation.longitude}');
          if (secondAddress != null && secondAddress.isNotEmpty) {
            debugPrint('   상세주소: $secondAddress');
          }
          if (mounted) {
            setState(() {
              _homeLocation = LatLng(homeLocation.latitude, homeLocation.longitude);
            });
          }
        } else {
          // 구버전 데이터: 주소 문자열만 있는 경우 (geocoding 시도)
          final address = userData?['address'] as String?;
          debugPrint('⚠️ 집주소 좌표 미저장 (구버전 데이터)');
          debugPrint('   주소: $address');

          if (address != null && address.isNotEmpty) {
            final homeCoords = await NominatimService.geocode(address);
            if (homeCoords != null) {
              debugPrint('✅ geocoding 성공: ${homeCoords.latitude}, ${homeCoords.longitude}');
              if (mounted) {
                setState(() {
                  _homeLocation = homeCoords;
                });
              }
            } else {
              debugPrint('❌ geocoding 실패 - 프로필에서 주소를 다시 설정하세요');
            }
          } else {
            debugPrint('❌ 집주소 정보 없음');
          }
        }

        // ===== 일터 주소 로드 =====
        final workplaceId = userData?['workplaceId'] as String?;
        final workLocations = <LatLng>[];

        if (workplaceId != null && workplaceId.isNotEmpty) {
          debugPrint('📍 일터 로드 시도: $workplaceId');

          // places 컬렉션에서 일터 정보 가져오기
          final placeDoc = await FirebaseFirestore.instance
              .collection('places')
              .doc(workplaceId)
              .get();

          if (placeDoc.exists) {
            final placeData = placeDoc.data();
            final workLocation = placeData?['location'] as GeoPoint?;

            if (workLocation != null) {
              // 저장된 GeoPoint 직접 사용
              debugPrint('✅ 일터 좌표 로드: ${workLocation.latitude}, ${workLocation.longitude}');
              workLocations.add(LatLng(workLocation.latitude, workLocation.longitude));
            } else {
              // 구버전: 주소만 있는 경우 geocoding 시도
              final workAddress = placeData?['address'] as String?;
              debugPrint('⚠️ 일터 좌표 미저장 (구버전 데이터)');
              debugPrint('   주소: $workAddress');

              if (workAddress != null && workAddress.isNotEmpty) {
                final workCoords = await NominatimService.geocode(workAddress);
                if (workCoords != null) {
                  debugPrint('✅ geocoding 성공: ${workCoords.latitude}, ${workCoords.longitude}');
                  workLocations.add(workCoords);
                } else {
                  debugPrint('❌ geocoding 실패');
                }
              }
            }
          } else {
            debugPrint('❌ 일터 정보 없음 (placeId: $workplaceId)');
          }
        } else {
          debugPrint('일터 미설정');
        }

        if (mounted) {
          setState(() {
            _workLocations = workLocations;
          });
        }

        debugPrint('최종 일터 좌표 개수: ${workLocations.length}');
      }

      // 과거 방문 위치 로드
      await _loadVisitedLocations();

      // 포그 오브 워 업데이트
      if (_currentPosition != null) {
        print('포그 오브 워 업데이트 시작');
        _rebuildFogWithUserLocations(_currentPosition!);
        print('포그 오브 워 업데이트 완료');
      }
    } catch (e) {
      debugPrint('사용자 위치 로드 실패: $e');
    }
  }

  Future<void> _loadVisitedLocations() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      // 30일 이내 방문 기록 가져오기 (올바른 컬렉션 경로 사용)
      final thirtyDaysAgo = DateTime.now().subtract(const Duration(days: 30));
      
      final visitedTiles = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .collection('visited_tiles')
          .where('lastVisitTime', isGreaterThanOrEqualTo: Timestamp.fromDate(thirtyDaysAgo))
          .get();

      final visitedPositions = <LatLng>[];
      
      for (final doc in visitedTiles.docs) {
        final tileId = doc.id;
        // 타일 ID에서 좌표 추출
        final position = _extractPositionFromTileId(tileId);
        if (position != null) {
          visitedPositions.add(position);
        }
      }

      print('과거 방문 위치 개수: ${visitedPositions.length}');
      
      // 회색 영역 생성
      final grayPolygons = OSMFogService.createGrayAreas(visitedPositions);

      if (mounted) {
        setState(() {
          _grayPolygons = grayPolygons;
        });
      }

    } catch (e) {
      debugPrint('방문 위치 로드 실패: $e');
    }
  }

  // 타일 ID에서 좌표 추출하는 헬퍼 메서드
  LatLng? _extractPositionFromTileId(String tileId) {
    try {
      // ✅ TileUtils의 표준 메서드 사용 (중복 로직 제거)
      return TileUtils.getKm1TileCenter(tileId);
    } catch (e) {
      debugPrint('타일 ID 변환 실패: $tileId - $e');
      return null;
    }
  }

  Future<void> _updateCurrentAddress() async {
    if (_currentPosition == null) return;
    
    try {
      final address = await NominatimService.reverseGeocode(_currentPosition!);
      if (mounted) {
        setState(() {
          _currentAddress = address;
        });
      }

      // 상위 위젯에 주소 전달
      widget.onAddressChanged?.call(address);
    } catch (e) {
      if (mounted) {
        setState(() {
          _currentAddress = '주소 변환 실패';
        });
      }
    }
  }

  // 🚀 Firestore 기반 실시간 마커 로드 (제거됨 - _setupPostStreamListener로 대체)

  Future<void> _loadPosts({bool forceRefresh = false}) async {
    if (_currentPosition == null) return;
    
    // 로딩 상태는 짧게만 표시
    if (forceRefresh) {
      setState(() {
        _isLoading = true;
      });
    }

    try {
      // 새로운 구조: MarkerService에서 직접 마커 조회
      await _updatePostsBasedOnFogLevel();
        
        if (mounted) {
          setState(() {
            _isLoading = false;
        });
      }
    } catch (e) {
      setState(() {
        _errorMessage = '마커를 불러오는 중 오류가 발생했습니다: $e';
        _isLoading = false;
      });
    }
  }


  // 맵 상태 업데이트 (클러스터링용)
  void _updateMapState() {
    if (_mapController != null) {
      final camera = _mapController!.camera;
      _mapCenter = camera.center;
      _mapZoom = camera.zoom;
      
      // 화면 크기 업데이트 (MediaQuery 사용)
      final size = MediaQuery.of(context).size;
      _lastMapSize = size;
      
      // 클러스터링 디바운스 타이머
      _clusterDebounceTimer?.cancel();
      _clusterDebounceTimer = Timer(const Duration(milliseconds: 32), _rebuildClusters);
    }
  }

  // 🚀 실시간 업데이트: 지도 이동 감지 및 마커 새로고침
  void _onMapMoved(MapEvent event) {
    // 맵 상태 업데이트
    _updateMapState();
    
    if (event is MapEventMove || event is MapEventMoveStart) {
      // 지도 이동 중이면 타이머 리셋 (디바운스 시간 증가)
      _mapMoveTimer?.cancel();
      _mapMoveTimer = Timer(const Duration(milliseconds: 500), () {
        _handleMapMoveComplete();
      });
      
      // 실시간으로 수령 가능 마커 개수 업데이트
      _updateReceivablePosts();
    }
  }

  // 지도 이동 완료 후 처리
  Future<void> _handleMapMoveComplete() async {
    if (_isUpdatingPosts) return; // 이미 업데이트 중이면 스킵
    
    final currentCenter = _mapController?.camera.center;
    if (currentCenter == null) return;
    
    // 캐시 키 기반 스킵 로직
    final newCacheKey = _generateCacheKeyForLocation(currentCenter);
    if (newCacheKey == _lastCacheKey) {
      print('🔄 동일 타일 위치 - 마커 업데이트 스킵');
      return;
    }
    
    // 이전 위치와 거리 계산 (200m 이상 이동했을 때만 업데이트)
    if (_lastMapCenter != null) {
      final distance = _calculateDistance(_lastMapCenter!, currentCenter);
      if (distance < 200) return; // 200m 미만 이동은 무시
      
      // 🔥 위치 이동 시 1단계 타일 캐시 초기화 (중요한 수정!)
      print('🧹 지도 이동 감지 - 1단계 타일 캐시 초기화');
      _clearFogLevel1Cache();
    }
    
    _isUpdatingPosts = true;
    
    try {
      print('🔄 지도 이동 감지 - 마커 업데이트 시작');
        
        // 현재 위치는 GPS에서만 업데이트 (맵센터로 업데이트하지 않음)
        
      // 🚀 서버 API를 통한 마커 조회
        await _updatePostsBasedOnFogLevel();
        
        // 수령 가능 포스트 개수 업데이트
        _updateReceivablePosts();
        
        // 마지막 상태 저장
        _lastMapCenter = currentCenter;
      _lastCacheKey = newCacheKey;
      
    } catch (e) {
      print('지도 이동 후 포스트 업데이트 실패: $e');
    } finally {
      _isUpdatingPosts = false;
    }
  }
  
  // 위치 기반 캐시 키 생성 - 주변 타일들도 고려하여 개선
  String _generateCacheKeyForLocation(LatLng location) {
    // 현재 위치의 1km 타일 ID
    final currentTileId = TileUtils.getKm1TileId(location.latitude, location.longitude);
    
    // 주변 1단계 타일들도 캐시 키에 포함 (정확도 향상)
    final surroundingTiles = TileUtils.getKm1SurroundingTiles(location.latitude, location.longitude);
    final tileIds = surroundingTiles.take(9).toList(); // 3x3 그리드만 고려
    
    // 타일 ID들을 정렬하여 일관된 캐시 키 생성
    tileIds.sort();
    final tileKey = tileIds.join('_');
    
    return 'fog_${currentTileId}_${tileKey.hashCode}';
  }

  // 현재 위치의 포그레벨 1단계 타일들 계산 - 개선된 로직
  Future<Set<String>> _getCurrentFogLevel1Tiles(LatLng center) async {
    try {
      // 🔥 캐시 만료 확인 및 초기화
      _checkAndClearExpiredFogLevel1Cache();
      
      final surroundingTiles = TileUtils.getKm1SurroundingTiles(center.latitude, center.longitude);
      final fogLevel1Tiles = <String>{};
      
      print('🔍 포그레벨 1+2단계 타일 계산 시작 (개선된 로직):');
      print('  - 중심 위치: ${center.latitude}, ${center.longitude}');
      print('  - 주변 타일 개수: ${surroundingTiles.length}');
      print('  - 로컬 캐시 타일 개수: ${_currentFogLevel1TileIds.length}');
      
      for (final tileId in surroundingTiles) {
        final tileCenter = TileUtils.getKm1TileCenter(tileId);
        final distToCenterKm = _calculateDistance(center, tileCenter);
        
        // 타일의 실제 크기 계산 (정확한 반지름)
        final tileBounds = TileUtils.getKm1TileBounds(tileId);
        final tileRadiusKm = _calculateTileRadiusKm(tileBounds);
        
        print('  - 타일 $tileId: 중심거리 ${distToCenterKm.toStringAsFixed(2)}km, 타일반지름 ${tileRadiusKm.toStringAsFixed(2)}km');
        
        // 🔥 개선된 로직: 거리 기반 우선 판단, 로컬 캐시는 보조적으로만 사용
        if (distToCenterKm <= (1.0 + tileRadiusKm)) {
          // 1km 반지름과 타일이 겹침 - 무조건 1단계
          fogLevel1Tiles.add(tileId);
          print('    ✅ 1km+타일반지름 이내 - 포그레벨 1 추가');
          
          // 로컬 캐시에도 추가 (다음 계산 시 빠른 접근용)
          if (!_currentFogLevel1TileIds.contains(tileId)) {
            _currentFogLevel1TileIds.add(tileId);
          }
        } else {
          // 1km 밖은 방문 기록 확인 (포그레벨 2)
          final fogLevel = await VisitTileService.getFogLevelForTile(tileId);
          print('    🔍 1km+타일반지름 밖 - 포그레벨: $fogLevel');
          if (fogLevel == FogLevel.clear || fogLevel == FogLevel.gray) {
            fogLevel1Tiles.add(tileId);
            print('    ✅ 포그레벨 1+2 영역 - 마커 표시 가능');
            
            // 방문 기록이 있는 타일도 로컬 캐시에 추가
            if (!_currentFogLevel1TileIds.contains(tileId)) {
              _currentFogLevel1TileIds.add(tileId);
            }
          } else {
            // 포그레벨 3 이상이면 로컬 캐시에서 제거 (정확성 향상)
            if (_currentFogLevel1TileIds.contains(tileId)) {
              _currentFogLevel1TileIds.remove(tileId);
              print('    🗑️ 로컬 캐시에서 제거됨 (포그레벨 3 이상): $tileId');
            }
          }
        }
      }
      
      print('✅ 최종 포그레벨 1+2 타일 개수: ${fogLevel1Tiles.length}');
      
      // 🔥 캐시 계산 완료 시 타임스탬프 업데이트
      _updateFogLevel1CacheTimestamp();
      
      return fogLevel1Tiles;
    } catch (e) {
      print('포그레벨 1+2단계 타일 계산 실패: $e');
      return {};
    }
  }

  /// 타일 반지름 계산 (km) - 정확한 계산
  double _calculateTileRadiusKm(Map<String, double> bounds) {
    // 타일의 중심점
    final center = LatLng(
      (bounds['minLat']! + bounds['maxLat']!) / 2, 
      (bounds['minLng']! + bounds['maxLng']!) / 2,
    );
    
    // 타일의 네 모서리 중 가장 먼 거리 계산
    final corners = [
      LatLng(bounds['minLat']!, bounds['minLng']!), // 남서쪽
      LatLng(bounds['minLat']!, bounds['maxLng']!), // 남동쪽
      LatLng(bounds['maxLat']!, bounds['minLng']!), // 북서쪽
      LatLng(bounds['maxLat']!, bounds['maxLng']!), // 북동쪽
    ];
    
    double maxDistance = 0;
    for (final corner in corners) {
      final distance = _calculateDistance(center, corner);
      if (distance > maxDistance) {
        maxDistance = distance;
      }
    }
    
    return maxDistance;
  }

  /// 타일 반대각선 절반 길이 계산 (km) - 기존 호환성 유지
  double _approxTileHalfDiagonalKm(Map<String, double> bounds) {
    final center = LatLng(
      (bounds['minLat']! + bounds['maxLat']!) / 2, 
      (bounds['minLng']! + bounds['maxLng']!) / 2
    );
    final corner = LatLng(bounds['maxLat']!, bounds['maxLng']!);
    final diag = _calculateDistance(center, corner) * 2; // center→corner*2 ≈ 전체 대각선
    return diag / 2.0;
  }

  /// 방금 방문한 타일을 로컬에 즉시 반영
  void _setLevel1TileLocally(String tileId) {
    setState(() {
      _currentFogLevel1TileIds.add(tileId);
    });
    print('🚀 타일 $tileId 로컬에 즉시 반영됨');
  }


  /// 1단계 타일 캐시 초기화 (지도 이동 시 호출)
  void _clearFogLevel1Cache() {
    setState(() {
      _currentFogLevel1TileIds.clear();
      _fogLevel1CacheTimestamp = null;
    });
    print('🧹 1단계 타일 캐시 초기화 완료');
  }

  /// 1단계 타일 캐시 만료 확인 및 초기화
  void _checkAndClearExpiredFogLevel1Cache() {
    if (_fogLevel1CacheTimestamp != null) {
      final now = DateTime.now();
      if (now.difference(_fogLevel1CacheTimestamp!) > _fogLevel1CacheExpiry) {
        print('⏰ 1단계 타일 캐시 만료 - 자동 초기화');
        _clearFogLevel1Cache();
      }
    }
  }

  /// 1단계 타일 캐시 업데이트 (타임스탬프 포함)
  void _updateFogLevel1CacheTimestamp() {
    _fogLevel1CacheTimestamp = DateTime.now();
  }

  // 두 타일 세트가 같은지 비교
  bool _areTileSetsEqual(Set<String> set1, Set<String> set2) {
    if (set1.length != set2.length) return false;
    return set1.every((tile) => set2.contains(tile));
  }

  // GPS 활성화 요청 다이얼로그
  void _showLocationPermissionDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Row(
            children: [
              Icon(Icons.location_on, color: Colors.blue),
              SizedBox(width: 8),
              Text('위치 서비스 필요'),
            ],
          ),
          content: const Text(
            '지도에서 마커를 보려면 GPS를 활성화해주세요.\n\n'
            '설정 > 개인정보 보호 및 보안 > 위치 서비스에서\n'
            '앱의 위치 권한을 허용해주세요.',
            style: TextStyle(fontSize: 16),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
                _getCurrentLocation(); // 위치 다시 요청
              },
              child: const Text('다시 시도'),
            ),
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text('나중에'),
            ),
          ],
        );
      },
    );
  }

  // 🚀 서버 API를 통한 마커 조회
  Future<void> _updatePostsBasedOnFogLevel() async {
    // Mock 모드에서는 Mock 위치 사용, 아니면 실제 GPS 위치 사용
    LatLng? effectivePosition;
    if (_isMockModeEnabled && _mockPosition != null) {
      effectivePosition = _mockPosition;
      print('🎭 Mock 모드 - Mock 위치 사용: ${_mockPosition!.latitude}, ${_mockPosition!.longitude}');
    } else {
      effectivePosition = _currentPosition;
      print('📍 GPS 모드 - 실제 위치 사용: ${_currentPosition?.latitude}, ${_currentPosition?.longitude}');
    }
    
    // 위치가 없으면 GPS 활성화 요청
    if (effectivePosition == null) {
      _showLocationPermissionDialog();
      return;
    }
    
    final centers = <LatLng>[];
    centers.add(effectivePosition);
    print('📍 기준 위치: ${effectivePosition.latitude}, ${effectivePosition.longitude}');
      
      // 집주소 추가
      if (_homeLocation != null) {
      centers.add(_homeLocation!);
      print('🏠 집주소: ${_homeLocation!.latitude}, ${_homeLocation!.longitude}');
      }
      
      // 등록한 일터들 추가
    centers.addAll(_workLocations);
      for (int i = 0; i < _workLocations.length; i++) {
      print('🏢 일터${i + 1}: ${_workLocations[i].latitude}, ${_workLocations[i].longitude}');
    }
    
    print('🎯 총 ${centers.length}개의 기준점에서 마커 검색');

    try {
      print('🔍 _updatePostsBasedOnFogLevel 호출됨');

      // 2. 필터 설정
      final filters = <String, dynamic>{
        'showCouponsOnly': _showCouponsOnly,
        'myPostsOnly': _showMyPostsOnly,
        'minReward': _minReward,
        'showUrgentOnly': _showUrgentOnly,
        'showVerifiedOnly': _showVerifiedOnly, // 인증 필터 추가
        'showUnverifiedOnly': _showUnverifiedOnly, // 미인증 필터 추가
      };
      
      print('');
      print('🟢🟢🟢 ========== 필터 상태 확인 ========== 🟢🟢🟢');
      print('🟢 _showMyPostsOnly: $_showMyPostsOnly');
      print('🟢 _showVerifiedOnly: $_showVerifiedOnly');
      print('🟢 _showUnverifiedOnly: $_showUnverifiedOnly');
      print('🟢 _showCouponsOnly: $_showCouponsOnly');
      print('🟢 _showUrgentOnly: $_showUrgentOnly');
      print('🟢 전달되는 filters 맵: $filters');
      print('🟢🟢🟢 ====================================== 🟢🟢🟢');
      print('');

      // 3. 서버에서 일반 포스트와 슈퍼포스트를 병렬로 조회
      final primaryCenter = centers.first; // 첫 번째 중심점 사용
      final additionalCenters = centers.skip(1).toList(); // 나머지는 추가 중심점
      
      // 사용자 타입에 따른 거리 계산
      final normalRadiusKm = MarkerService.getMarkerDisplayRadius(_userType, false) / 1000.0;
      final superRadiusKm = MarkerService.getMarkerDisplayRadius(_userType, true) / 1000.0;
      
      print('🔍 서버 호출 시작:');
      print('  - 주 중심점: ${primaryCenter.latitude}, ${primaryCenter.longitude}');
      print('  - 추가 중심점: ${additionalCenters.length}개');
      print('  - 일반 포스트 반경: ${normalRadiusKm}km');
      print('  - 슈퍼포스트 반경: ${superRadiusKm}km');
      
      final futures = await Future.wait([
        // 일반 포스트 조회
        MapMarkerService.getMarkers(
          location: primaryCenter,
          radiusInKm: normalRadiusKm, // 사용자 타입에 따른 거리
          additionalCenters: additionalCenters,
          filters: filters,
          pageSize: 1000, // ✅ 제한 증가 (영역 내에서만 조회하므로)
        ),
        // 슈퍼마커 조회
        MapMarkerService.getSuperMarkers(
          location: primaryCenter,
          radiusInKm: superRadiusKm, // 슈퍼포스트는 항상 5km
          additionalCenters: additionalCenters,
          filters: filters, // ✅ 필터 전달
          pageSize: 500, // ✅ 제한 증가
        ),
      ]);

      final normalMarkers = futures[0] as List<MapMarkerData>;
      final superMarkers = futures[1] as List<MapMarkerData>;
      
      print('📍 서버 응답:');
      print('  - 일반 마커: ${normalMarkers.length}개');
      print('  - 슈퍼마커: ${superMarkers.length}개');
      
      // 🔥 Fail-open: 마커가 없으면 경고 메시지
      if (normalMarkers.isEmpty && superMarkers.isEmpty) {
        print('⚠️ 마커가 없습니다! 가능한 원인:');
        print('  - 위치 권한 문제');
        print('  - 서버 필터가 너무 강함');
        print('  - 포그레벨 1 타일이 없음');
        print('  - Firestore 데이터 없음');
      }

      // 4. 모든 마커를 합치고 중복 제거
      final allMarkers = <MapMarkerData>[];
      final seenMarkerIds = <String>{};
      
      // 일반 포스트 추가
      for (final marker in normalMarkers) {
        if (!seenMarkerIds.contains(marker.id)) {
          allMarkers.add(marker);
          seenMarkerIds.add(marker.id);
        }
      }
      
      // 슈퍼마커 추가
      for (final marker in superMarkers) {
        if (!seenMarkerIds.contains(marker.id)) {
          allMarkers.add(marker);
          seenMarkerIds.add(marker.id);
        }
      }

      // 5. MarkerData를 MarkerModel로 변환
      final uniqueMarkers = allMarkers.map((markerData) => 
        MapMarkerService.convertToMarkerModel(markerData)
      ).toList();

      // 6. 이미 수령한 포스트 필터링
      final currentUser = FirebaseAuth.instance.currentUser;
      Set<String> collectedPostIds = {};
      
      if (currentUser != null) {
        try {
          print('🔍 이미 수령한 포스트 확인 중...');
          final collectedSnapshot = await FirebaseFirestore.instance
              .collection('post_collections')
              .where('userId', isEqualTo: currentUser.uid)
              .get();
          
          collectedPostIds = collectedSnapshot.docs
              .map((doc) => doc.data()['postId'] as String)
              .toSet();
          
          print('📦 이미 수령한 포스트: ${collectedPostIds.length}개');
        } catch (e) {
          print('❌ 수령 기록 조회 실패: $e');
        }
      }
      
      // 이미 수령한 포스트의 마커 제거
      final filteredMarkers = uniqueMarkers.where((marker) {
        final isCollected = collectedPostIds.contains(marker.postId);
        if (isCollected) {
          print('🚫 이미 수령한 포스트의 마커 제거: ${marker.title} (postId: ${marker.postId})');
        }
        return !isCollected;
      }).toList();
      
      print('✅ 필터링 후 마커: ${filteredMarkers.length}개 (${uniqueMarkers.length - filteredMarkers.length}개 제거됨)');

      // 7. 포스트 정보도 함께 가져오기
      final postIds = filteredMarkers.map((marker) => marker.postId).toSet().toList();
      final posts = <PostModel>[];
      
      if (postIds.isNotEmpty) {
        try {
          final postSnapshots = await FirebaseFirestore.instance
              .collection('posts')
              .where('postId', whereIn: postIds)
              .get();
          
          for (final doc in postSnapshots.docs) {
            try {
              final post = PostModel.fromFirestore(doc);
              posts.add(post);
            } catch (e) {
              print('포스트 파싱 오류: $e');
            }
          }
          
          print('📄 포스트 정보 조회 완료: ${posts.length}개');
        } catch (e) {
          print('❌ 포스트 정보 조회 실패: $e');
        }
      }

      setState(() {
        _markers = filteredMarkers;
        _posts = posts; // 포스트 정보도 업데이트
        _isLoading = false;
        print('✅ _updatePostsBasedOnFogLevel: 총 ${_markers.length}개의 고유 마커, ${_posts.length}개의 포스트 업데이트됨');
        _updateMarkers(); // 마커 업데이트 후 지도 마커도 업데이트
      });

    } catch (e, stackTrace) {
      print('❌ _updatePostsBasedOnFogLevel 오류: $e');
      print('📚 스택 트레이스: $stackTrace');
      
      // 🔥 Fail-open: 에러 발생 시에도 기본 마커라도 표시
      print('🔄 에러 발생 - 기본 마커 표시 시도');
      
      setState(() {
        _isLoading = false;
        _errorMessage = '마커를 불러오는 중 오류가 발생했습니다: $e';
        
        // 에러 발생 시 빈 마커 리스트로 설정 (무한 로딩 방지)
        _markers = [];
        _updateMarkers();
      });
    }
  }

  // 포그레벨에 따른 마커 필터링
  Future<void> _filterPostsByFogLevel(Set<String> fogLevel1Tiles) async {
    try {
      // 새로운 구조: MarkerService에서 직접 마커 조회
      await _updatePostsBasedOnFogLevel();
      
    } catch (e) {
      print('마커 필터링 실패: $e');
    }
  }

  /// 현재위치, 집, 일터 주변에서 롱프레스 가능한지 확인
  bool _canLongPressAtLocation(LatLng point) {
    final maxRadius = MarkerService.getMarkerDisplayRadius(_userType, false);
    
    // Mock 모드에서는 Mock 위치를 기준으로, 아니면 실제 GPS 위치를 기준으로 확인
    LatLng? referencePosition;
    if (_isMockModeEnabled && _mockPosition != null) {
      referencePosition = _mockPosition;
    } else {
      referencePosition = _currentPosition;
    }
    
    // 기준 위치 주변 확인
    if (referencePosition != null) {
      final distanceToCurrent = MarkerService.calculateDistance(
        LatLng(referencePosition.latitude, referencePosition.longitude),
        point,
      );
      if (distanceToCurrent <= maxRadius) {
        return true;
      }
    }
    
    // 집 주변 확인
    if (_homeLocation != null) {
      final distanceToHome = MarkerService.calculateDistance(
        LatLng(_homeLocation!.latitude, _homeLocation!.longitude),
        point,
      );
      if (distanceToHome <= maxRadius) {
        return true;
      }
    }
    
    // 일터 주변 확인
    for (final workLocation in _workLocations) {
      final distanceToWork = MarkerService.calculateDistance(
        LatLng(workLocation.latitude, workLocation.longitude),
