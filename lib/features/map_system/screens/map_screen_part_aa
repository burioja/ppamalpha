import 'dart:async';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import 'package:geolocator/geolocator.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../../core/models/post/post_model.dart';
import '../../../core/models/user/user_model.dart';  // UserModelê³¼ UserType ì¶”ê°€
import '../../../core/services/data/post_service.dart';
import '../../../core/services/data/marker_service.dart';  // MarkerService ì¶”ê°€
import '../../../core/services/data/user_service.dart';  // UserService ì¶”ê°€
import '../../../core/constants/app_constants.dart';
import '../services/markers/marker_service.dart';
import '../../../core/models/marker/marker_model.dart';
import 'package:latlong2/latlong.dart';
import '../widgets/marker_layer_widget.dart';
import '../utils/client_cluster.dart';
import '../widgets/cluster_widgets.dart';
import '../../post_system/controllers/post_deployment_controller.dart';
import '../../../core/services/osm_geocoding_service.dart';
import '../../post_system/widgets/address_search_dialog.dart';
// OSM ê¸°ë°˜ Fog of War ì‹œìŠ¤í…œ
import '../services/external/osm_fog_service.dart';
import '../services/fog_of_war/visit_tile_service.dart';
import '../widgets/unified_fog_overlay_widget.dart';
import '../../../core/services/location/nominatim_service.dart';
import '../../../core/services/location/location_service.dart';
import '../../../utils/tile_utils.dart';
import '../../../core/models/map/fog_level.dart';
import '../models/receipt_item.dart';
import '../widgets/receive_carousel.dart';
import 'package:vibration/vibration.dart';
import 'package:audioplayers/audioplayers.dart' as audio;

/// ë§ˆì»¤ ì•„ì´í…œ í´ë˜ìŠ¤
class MarkerItem {
  final String id;
  final String title;
  final String price;
  final String amount;
  final String userId;
  final Map<String, dynamic> data;
  final LatLng position;
  final String? imageUrl;
  final int remainingAmount;
  final DateTime? expiryDate;

  MarkerItem({
    required this.id,
    required this.title,
    required this.price,
    required this.amount,
    required this.userId,
    required this.data,
    required this.position,
    this.imageUrl,
    required this.remainingAmount,
    this.expiryDate,
  });
}

class MapScreen extends StatefulWidget {
  final Function(String)? onAddressChanged;
  final VoidCallback? onNavigateToInbox;
  
  const MapScreen({super.key, this.onAddressChanged, this.onNavigateToInbox});
  static final GlobalKey<_MapScreenState> mapKey = GlobalKey<_MapScreenState>();

  @override
  _MapScreenState createState() => _MapScreenState();
}

class _MapScreenState extends State<MapScreen> {
  // OSM ê¸°ë°˜ Fog of War ìƒíƒœ
  List<Polygon> _grayPolygons = []; // íšŒìƒ‰ ì˜ì—­ë“¤ (ê³¼ê±° ë°©ë¬¸ ìœ„ì¹˜)
  List<CircleMarker> _ringCircles = [];
  List<Marker> _currentMarkers = [];
  
  // í´ëŸ¬ìŠ¤í„°ë§ ê´€ë ¨ ë³€ìˆ˜ë“¤
  List<Marker> _clusteredMarkers = [];
  Size _lastMapSize = const Size(0, 0);
  LatLng _mapCenter = const LatLng(37.5665, 126.9780); // ì„œìš¸ ê¸°ë³¸ê°’
  double _mapZoom = 10.0;
  
  // ìƒˆë¡œìš´ í´ëŸ¬ìŠ¤í„°ë§ ì‹œìŠ¤í…œìš© ë³€ìˆ˜ë“¤
  Timer? _clusterDebounceTimer;
  List<ClusterMarkerModel> _visibleMarkerModels = [];
  
  // ì‚¬ìš©ì ìœ„ì¹˜ ì •ë³´
  LatLng? _homeLocation;
  List<LatLng> _workLocations = [];
  
  // ê¸°ë³¸ ìƒíƒœ
  MapController? _mapController;
  LatLng? _currentPosition;
  double _currentZoom = 14.0;
  String _currentAddress = 'ìœ„ì¹˜ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...';
  LatLng? _longPressedLatLng;
  Widget? _customMarkerIcon;
  
  
  // í¬ìŠ¤íŠ¸ ê´€ë ¨
  List<PostModel> _posts = [];
  List<MarkerModel> _markers = []; // ìƒˆë¡œìš´ ë§ˆì»¤ ëª¨ë¸ ì‚¬ìš©
  bool _isLoading = false;
  String? _errorMessage;
  
  // í•„í„° ê´€ë ¨
  bool _showFilter = false;
  String _selectedCategory = 'all';
  double _maxDistance = 1000.0; // ê¸°ë³¸ 1km, ìœ ë£ŒíšŒì› 3km
  int _minReward = 0;
  bool _showCouponsOnly = false;
  bool _showMyPostsOnly = false;
  bool _showUrgentOnly = false; // ë§ˆê°ì„ë°• í•„í„° ì¶”ê°€
  bool _showVerifiedOnly = false; // ì¸ì¦ í¬ìŠ¤íŠ¸ë§Œ í•„í„° ì¶”ê°€
  bool _showUnverifiedOnly = false; // ë¯¸ì¸ì¦ í¬ìŠ¤íŠ¸ë§Œ í•„í„° ì¶”ê°€
  bool _isPremiumUser = false; // ìœ ë£Œ ì‚¬ìš©ì ì—¬ë¶€
  UserType _userType = UserType.normal; // ì‚¬ìš©ì íƒ€ì… ì¶”ê°€
  
  // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ê´€ë ¨
  Timer? _mapMoveTimer;
  LatLng? _lastMapCenter;
  Set<String> _lastFogLevel1Tiles = {};
  bool _isUpdatingPosts = false;

  // í¬ìŠ¤íŠ¸ ìˆ˜ë ¹ ê´€ë ¨
  int _receivablePostCount = 0;
  bool _isReceiving = false;
  String? _lastCacheKey; // ìºì‹œ í‚¤ ê¸°ë°˜ ìŠ¤í‚µìš©
  
  // ë¡œì»¬ í¬ê·¸ë ˆë²¨ 1 íƒ€ì¼ ìºì‹œ (ì¦‰ì‹œ ë°˜ì˜ìš©)
  Set<String> _currentFogLevel1TileIds = {};
  DateTime? _fogLevel1CacheTimestamp;
  static const Duration _fogLevel1CacheExpiry = Duration(minutes: 5); // 5ë¶„ í›„ ìºì‹œ ë§Œë£Œ
  
  // í¬ê·¸ë ˆë²¨ ë³€ê²½ ê°ì§€ ê´€ë ¨
  Map<String, int> _tileFogLevels = {}; // íƒ€ì¼ë³„ í¬ê·¸ë ˆë²¨ ìºì‹œ
  Set<String> _visiblePostIds = {}; // í˜„ì¬ í‘œì‹œ ì¤‘ì¸ í¬ìŠ¤íŠ¸ IDë“¤
  
  
  // í´ëŸ¬ìŠ¤í„°ë§ ê´€ë ¨
  bool _isClustered = false;
  static const double _clusterRadius = 50.0; // í”½ì…€ ë‹¨ìœ„
  
  // ìœ„ì¹˜ ì´ë™ ê´€ë ¨
  int _currentWorkplaceIndex = 0; // í˜„ì¬ ì¼í„° ì¸ë±ìŠ¤
  
  // Mock ìœ„ì¹˜ ê´€ë ¨ ìƒíƒœ
  bool _isMockModeEnabled = false;
  bool _isMockControllerVisible = false;
  LatLng? _mockPosition;
  LatLng? _originalGpsPosition; // ì›ë˜ GPS ìœ„ì¹˜ ë°±ì—…
  LatLng? _previousMockPosition; // ì´ì „ Mock ìœ„ì¹˜ (íšŒìƒ‰ ì˜ì—­ í‘œì‹œìš©)
  LatLng? _previousGpsPosition; // ì´ì „ GPS ìœ„ì¹˜ (íšŒìƒ‰ ì˜ì—­ í‘œì‹œìš©)
  
  // âœ… ì¼í„° ë¦¬ìŠ¤ë„ˆ êµ¬ë… ê´€ë¦¬ (ì¤‘ë³µ ë°©ì§€)
  StreamSubscription<DocumentSnapshot>? _workplaceSubscription;

  @override
  void initState() {
    super.initState();
    _mapController = MapController();
    
    _initializeLocation();
    _loadCustomMarker();
    _loadUserLocations();
    _setupUserDataListener();
    _setupMarkerListener();
    _updateReceivablePosts(); // ìˆ˜ë ¹ ê°€ëŠ¥ í¬ìŠ¤íŠ¸ ê°œìˆ˜ ì´ˆê¸°í™”
    // _checkPremiumStatus()ì™€ _setupPostStreamListener()ëŠ” _getCurrentLocation()ì—ì„œ í˜¸ì¶œë¨
    
  }

  void _setupUserDataListener() {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      print('ì‚¬ìš©ì ë°ì´í„° ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì‹¤íŒ¨: ì‚¬ìš©ìê°€ ë¡œê·¸ì¸í•˜ì§€ ì•ŠìŒ');
      return;
    }

    print('ì‚¬ìš©ì ë°ì´í„° ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì‹œì‘: ${user.uid}');

    // ì‚¬ìš©ì ë°ì´í„° ë³€ê²½ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ê°ì§€
    FirebaseFirestore.instance
        .collection('users')
        .doc(user.uid)
        .snapshots()
        .listen((snapshot) {
      if (snapshot.exists) {
        print('ì‚¬ìš©ì ë°ì´í„° ë³€ê²½ ê°ì§€ë¨ - íƒ€ì„ìŠ¤íƒ¬í”„: ${DateTime.now()}');
        final data = snapshot.data();
        if (data != null) {
          final workplaces = data['workplaces'] as List<dynamic>?;
          print('ë³€ê²½ëœ ê·¼ë¬´ì§€ ê°œìˆ˜: ${workplaces?.length ?? 0}');
          
          // ì‚¬ìš©ì íƒ€ì… ë¡œë“œ
          final userModel = UserModel.fromFirestore(snapshot);
          if (mounted) {
            setState(() {
              _userType = userModel.userType;
              _isPremiumUser = userModel.userType == UserType.superSite;
            });
          }
          
          // âœ… ì¼í„° ë³€ê²½ ê°ì§€ë¥¼ ìœ„í•œ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
          final workplaceId = data['workplaceId'] as String?;
          if (workplaceId != null && workplaceId.isNotEmpty) {
            _setupWorkplaceListener(workplaceId);
          }
        }
        _loadUserLocations();
      } else {
        print('ì‚¬ìš©ì ë°ì´í„°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ');
      }
    }, onError: (error) {
      print('ì‚¬ìš©ì ë°ì´í„° ë¦¬ìŠ¤ë„ˆ ì˜¤ë¥˜: $error');
    });
  }

  // âœ… ì¼í„°(Place) ë³€ê²½ì‚¬í•­ ì‹¤ì‹œê°„ ê°ì§€ ë¦¬ìŠ¤ë„ˆ
  void _setupWorkplaceListener(String workplaceId) {
    print('ğŸ’¼ ì¼í„° ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì‹œì‘: $workplaceId');
    
    // âœ… ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆ ì·¨ì†Œ (ì¤‘ë³µ ë°©ì§€)
    _workplaceSubscription?.cancel();
    
    // âœ… ìƒˆë¡œìš´ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
    _workplaceSubscription = FirebaseFirestore.instance
        .collection('places')
        .doc(workplaceId)
        .snapshots()
        .listen((snapshot) {
      if (snapshot.exists) {
        print('ğŸ’¼ ì¼í„° ì •ë³´ ë³€ê²½ ê°ì§€ë¨ - íƒ€ì„ìŠ¤íƒ¬í”„: ${DateTime.now()}');
        final data = snapshot.data();
        if (data != null) {
          final location = data['location'] as GeoPoint?;
          print('ğŸ’¼ ë³€ê²½ëœ ì¼í„° ì¢Œí‘œ: ${location?.latitude}, ${location?.longitude}');
          
          // ì¼í„° ìœ„ì¹˜ ì •ë³´ ìƒˆë¡œê³ ì¹¨
          _loadUserLocations();
        }
      }
    }, onError: (error) {
      print('âŒ ì¼í„° ë¦¬ìŠ¤ë„ˆ ì˜¤ë¥˜: $error');
    });
  }

  void _setupMarkerListener() {
    if (_currentPosition == null) return;

    print('ë§ˆì»¤ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì‹œì‘');
  }


  // ìœ ë£Œ ì‚¬ìš©ì ìƒíƒœ í™•ì¸
  Future<void> _checkPremiumStatus() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .get();

      if (userDoc.exists) {
        final userData = userDoc.data();
        final isPremium = userData?['isPremium'] ?? false;

        if (mounted) {
          setState(() {
            _isPremiumUser = isPremium;
            _maxDistance = isPremium ? 3000.0 : 1000.0; // ìœ ë£Œ: 3km, ë¬´ë£Œ: 1km
          });
        }

        print('ğŸ’° ìœ ë£Œ ì‚¬ìš©ì ìƒíƒœ: $_isPremiumUser, ê²€ìƒ‰ ë°˜ê²½: ${_maxDistance}m');
      }
    } catch (e) {
      print('ìœ ë£Œ ì‚¬ìš©ì ìƒíƒœ í™•ì¸ ì‹¤íŒ¨: $e');
    }
  }


  // ğŸš€ ë§ˆì»¤ ì„œë¹„ìŠ¤ ë¦¬ìŠ¤ë„ˆ ì„¤ì • (í¬ìŠ¤íŠ¸ ì¡°íšŒ ì œê±°)
  void _setupPostStreamListener() {
    if (_currentPosition == null) {
      print('âŒ _setupPostStreamListener: _currentPositionì´ nullì…ë‹ˆë‹¤');
      return;
    }

    print('ğŸš€ ë§ˆì»¤ ì„œë¹„ìŠ¤ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì‹œì‘');
    print('ğŸ“ í˜„ì¬ ìœ„ì¹˜: ${_currentPosition!.latitude}, ${_currentPosition!.longitude}');
    print('ğŸ’° ìœ ë£Œ ì‚¬ìš©ì: $_isPremiumUser');
    print('ğŸ“ ê²€ìƒ‰ ë°˜ê²½: ${_maxDistance}m (${_maxDistance / 1000.0}km)');

    // ìƒˆë¡œìš´ êµ¬ì¡°: MarkerServiceì—ì„œ ì§ì ‘ ë§ˆì»¤ ì¡°íšŒ
    _updatePostsBasedOnFogLevel();
  }

  void _loadCustomMarker() {
    _customMarkerIcon = Container(
      width: 40,
      height: 40,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(color: Colors.white, width: 2),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.3),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: ClipOval(
        child: Image.asset(
          'assets/images/ppam_work.png',
          width: 36,
          height: 36,
          fit: BoxFit.cover,
        ),
          ),
        );
      }

  Future<void> _initializeLocation() async {
    try {
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          if (mounted) {
            setState(() {
              _errorMessage = 'ìœ„ì¹˜ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.';
            });
          }
          return;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        if (mounted) {
          setState(() {
            _errorMessage = 'ìœ„ì¹˜ ê¶Œí•œì´ ì˜êµ¬ì ìœ¼ë¡œ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ì„¤ì •ì—ì„œ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.';
          });
        }
        return;
      }

      await _getCurrentLocation();
    } catch (e) {
      if (mounted) {
        setState(() {
          _errorMessage = 'ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: $e';
        });
      }
    }
  }

  Future<void> _getCurrentLocation() async {
    // Mock ëª¨ë“œê°€ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ GPS ìœ„ì¹˜ ìš”ì²­í•˜ì§€ ì•ŠìŒ
    if (_isMockModeEnabled && _mockPosition != null) {
      print('ğŸ­ Mock ëª¨ë“œ í™œì„±í™” - GPS ìœ„ì¹˜ ìš”ì²­ ìŠ¤í‚µ');
      return;
    }
    
    try {
      print('ğŸ“ í˜„ì¬ ìœ„ì¹˜ ìš”ì²­ ì¤‘...');
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10),
      );
      
      print('âœ… í˜„ì¬ ìœ„ì¹˜ íšë“ ì„±ê³µ: ${position.latitude}, ${position.longitude}');
      print('   - ì •í™•ë„: ${position.accuracy}m');
      print('   - ê³ ë„: ${position.altitude}m');
      print('   - ì†ë„: ${position.speed}m/s');
      
      final newPosition = LatLng(position.latitude, position.longitude);

      // ì´ì „ GPS ìœ„ì¹˜ ì €ì¥ (íšŒìƒ‰ ì˜ì—­ í‘œì‹œìš©)
      final previousGpsPosition = _currentPosition;

      if (mounted) {
        setState(() {
          _currentPosition = newPosition;
          _errorMessage = null;
        });
      }

      // OSM Fog of War ì¬êµ¬ì„±
      _rebuildFogWithUserLocations(newPosition);
      
      // ì£¼ì†Œ ì—…ë°ì´íŠ¸
      _updateCurrentAddress();
      
      // íƒ€ì¼ ë°©ë¬¸ ê¸°ë¡ ì—…ë°ì´íŠ¸ (ìƒˆë¡œìš´ ê¸°ëŠ¥)
      final tileId = TileUtils.getKm1TileId(newPosition.latitude, newPosition.longitude);
      print('   - íƒ€ì¼ ID: $tileId');
      await VisitTileService.updateCurrentTileVisit(tileId);
      
      // ì¦‰ì‹œ ë°˜ì˜ (ë Œë”ë§ìš© ë©”ëª¨ë¦¬ ìºì‹œ)
      _setLevel1TileLocally(tileId);
      
      // íšŒìƒ‰ ì˜ì—­ ì—…ë°ì´íŠ¸ (ì´ì „ ìœ„ì¹˜ í¬í•¨)
      _updateGrayAreasWithPreviousPosition(previousGpsPosition);
      
      // ìœ ë£Œ ìƒíƒœ í™•ì¸ í›„ í¬ìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì„¤ì •
      await _checkPremiumStatus();
      
      // ğŸš€ ì‹¤ì‹œê°„ í¬ìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ë¦¬ìŠ¤ë„ˆ ì„¤ì • (ìœ„ì¹˜ í™•ë³´ í›„)
      _setupPostStreamListener();
      
      // ì¶”ê°€ë¡œ ë§ˆì»¤ ì¡°íšŒ ê°•ì œ ì‹¤í–‰ (ìœ„ì¹˜ ê¸°ë°˜ìœ¼ë¡œ ë” ì •í™•í•˜ê²Œ)
      print('ğŸš€ ìœ„ì¹˜ ì„¤ì • ì™„ë£Œ í›„ ë§ˆì»¤ ì¡°íšŒ ê°•ì œ ì‹¤í–‰');
      if (mounted) {
        setState(() {
          _isLoading = true;
        });
      }
      _updatePostsBasedOnFogLevel();
      
      // í˜„ì¬ ìœ„ì¹˜ ë§ˆì»¤ ìƒì„±
      _createCurrentLocationMarker(newPosition);
      
      // ì§€ë„ ì¤‘ì‹¬ ì´ë™
      _mapController?.move(newPosition, _currentZoom);

    } catch (e) {
      if (mounted) {
        setState(() {
          _errorMessage = 'í˜„ì¬ ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: $e';
        });
      }
    }
  }

  void _createCurrentLocationMarker(LatLng position) {
    final marker = Marker(
      point: position,
      width: 30,
      height: 30,
      child: Container(
          decoration: BoxDecoration(
            color: Colors.red,
            shape: BoxShape.circle,
            border: Border.all(color: Colors.white, width: 2),
          ),
          child: const Icon(
          Icons.my_location,
            color: Colors.white,
          size: 16,
        ),
      ),
        );

        if (mounted) {
          setState(() {
            _currentMarkers = [marker];
          });
        }
  }


  /// ëª¨ë“  ìœ„ì¹˜ë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œ (í˜„ì¬ ìœ„ì¹˜, ì§‘, ê·¼ë¬´ì§€)

  void _rebuildFogWithUserLocations(LatLng currentPosition) {
    final allPositions = <LatLng>[currentPosition];
    final ringCircles = <CircleMarker>[];

    print('í¬ê·¸ ì˜¤ë¸Œ ì›Œ ì¬êµ¬ì„± ì‹œì‘');
    print('í˜„ì¬ ìœ„ì¹˜: ${currentPosition.latitude}, ${currentPosition.longitude}');
    print('ì§‘ ìœ„ì¹˜: ${_homeLocation?.latitude}, ${_homeLocation?.longitude}');
    print('ê·¼ë¬´ì§€ ê°œìˆ˜: ${_workLocations.length}');

    // í˜„ì¬ ìœ„ì¹˜
    ringCircles.add(OSMFogService.createRingCircle(currentPosition));

    // ì§‘ ìœ„ì¹˜
    if (_homeLocation != null) {
      allPositions.add(_homeLocation!);
      ringCircles.add(OSMFogService.createRingCircle(_homeLocation!));
      print('ì§‘ ìœ„ì¹˜ ì¶”ê°€ë¨');
    }

    // ì¼í„° ìœ„ì¹˜ë“¤
    for (int i = 0; i < _workLocations.length; i++) {
      final workLocation = _workLocations[i];
      allPositions.add(workLocation);
      ringCircles.add(OSMFogService.createRingCircle(workLocation));
      print('ê·¼ë¬´ì§€ $i ì¶”ê°€ë¨: ${workLocation.latitude}, ${workLocation.longitude}');
    }

    print('ì´ ë°ì€ ì˜ì—­ ê°œìˆ˜: ${allPositions.length}');

    if (mounted) {
      setState(() {
        _ringCircles = ringCircles;
      });
    }

    print('í¬ê·¸ ì˜¤ë¸Œ ì›Œ ì¬êµ¬ì„± ì™„ë£Œ');
  }

  Future<void> _loadUserLocations() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      // ì‚¬ìš©ì í”„ë¡œí•„ì—ì„œ ì§‘ì£¼ì†Œ ê°€ì ¸ì˜¤ê¸°
      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .get();

      if (userDoc.exists) {
        final userData = userDoc.data();

        // ===== ì§‘ ì£¼ì†Œ ë¡œë“œ =====
        final homeLocation = userData?['homeLocation'] as GeoPoint?;
        final secondAddress = userData?['secondAddress'] as String?;

        if (homeLocation != null) {
          // ì €ì¥ëœ GeoPoint ì§ì ‘ ì‚¬ìš© (geocoding ë¶ˆí•„ìš”)
          debugPrint('âœ… ì§‘ì£¼ì†Œ ì¢Œí‘œ ë¡œë“œ: ${homeLocation.latitude}, ${homeLocation.longitude}');
          if (secondAddress != null && secondAddress.isNotEmpty) {
            debugPrint('   ìƒì„¸ì£¼ì†Œ: $secondAddress');
          }
          if (mounted) {
            setState(() {
              _homeLocation = LatLng(homeLocation.latitude, homeLocation.longitude);
            });
          }
        } else {
          // êµ¬ë²„ì „ ë°ì´í„°: ì£¼ì†Œ ë¬¸ìì—´ë§Œ ìˆëŠ” ê²½ìš° (geocoding ì‹œë„)
          final address = userData?['address'] as String?;
          debugPrint('âš ï¸ ì§‘ì£¼ì†Œ ì¢Œí‘œ ë¯¸ì €ì¥ (êµ¬ë²„ì „ ë°ì´í„°)');
          debugPrint('   ì£¼ì†Œ: $address');

          if (address != null && address.isNotEmpty) {
            final homeCoords = await NominatimService.geocode(address);
            if (homeCoords != null) {
              debugPrint('âœ… geocoding ì„±ê³µ: ${homeCoords.latitude}, ${homeCoords.longitude}');
              if (mounted) {
                setState(() {
                  _homeLocation = homeCoords;
                });
              }
            } else {
              debugPrint('âŒ geocoding ì‹¤íŒ¨ - í”„ë¡œí•„ì—ì„œ ì£¼ì†Œë¥¼ ë‹¤ì‹œ ì„¤ì •í•˜ì„¸ìš”');
            }
          } else {
            debugPrint('âŒ ì§‘ì£¼ì†Œ ì •ë³´ ì—†ìŒ');
          }
        }

        // ===== ì¼í„° ì£¼ì†Œ ë¡œë“œ =====
        final workplaceId = userData?['workplaceId'] as String?;
        final workLocations = <LatLng>[];

        if (workplaceId != null && workplaceId.isNotEmpty) {
          debugPrint('ğŸ“ ì¼í„° ë¡œë“œ ì‹œë„: $workplaceId');

          // places ì»¬ë ‰ì…˜ì—ì„œ ì¼í„° ì •ë³´ ê°€ì ¸ì˜¤ê¸°
          final placeDoc = await FirebaseFirestore.instance
              .collection('places')
              .doc(workplaceId)
              .get();

          if (placeDoc.exists) {
            final placeData = placeDoc.data();
            final workLocation = placeData?['location'] as GeoPoint?;

            if (workLocation != null) {
              // ì €ì¥ëœ GeoPoint ì§ì ‘ ì‚¬ìš©
              debugPrint('âœ… ì¼í„° ì¢Œí‘œ ë¡œë“œ: ${workLocation.latitude}, ${workLocation.longitude}');
              workLocations.add(LatLng(workLocation.latitude, workLocation.longitude));
            } else {
              // êµ¬ë²„ì „: ì£¼ì†Œë§Œ ìˆëŠ” ê²½ìš° geocoding ì‹œë„
              final workAddress = placeData?['address'] as String?;
              debugPrint('âš ï¸ ì¼í„° ì¢Œí‘œ ë¯¸ì €ì¥ (êµ¬ë²„ì „ ë°ì´í„°)');
              debugPrint('   ì£¼ì†Œ: $workAddress');

              if (workAddress != null && workAddress.isNotEmpty) {
                final workCoords = await NominatimService.geocode(workAddress);
                if (workCoords != null) {
                  debugPrint('âœ… geocoding ì„±ê³µ: ${workCoords.latitude}, ${workCoords.longitude}');
                  workLocations.add(workCoords);
                } else {
                  debugPrint('âŒ geocoding ì‹¤íŒ¨');
                }
              }
            }
          } else {
            debugPrint('âŒ ì¼í„° ì •ë³´ ì—†ìŒ (placeId: $workplaceId)');
          }
        } else {
          debugPrint('ì¼í„° ë¯¸ì„¤ì •');
        }

        if (mounted) {
          setState(() {
            _workLocations = workLocations;
          });
        }

        debugPrint('ìµœì¢… ì¼í„° ì¢Œí‘œ ê°œìˆ˜: ${workLocations.length}');
      }

      // ê³¼ê±° ë°©ë¬¸ ìœ„ì¹˜ ë¡œë“œ
      await _loadVisitedLocations();

      // í¬ê·¸ ì˜¤ë¸Œ ì›Œ ì—…ë°ì´íŠ¸
      if (_currentPosition != null) {
        print('í¬ê·¸ ì˜¤ë¸Œ ì›Œ ì—…ë°ì´íŠ¸ ì‹œì‘');
        _rebuildFogWithUserLocations(_currentPosition!);
        print('í¬ê·¸ ì˜¤ë¸Œ ì›Œ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
      }
    } catch (e) {
      debugPrint('ì‚¬ìš©ì ìœ„ì¹˜ ë¡œë“œ ì‹¤íŒ¨: $e');
    }
  }

  Future<void> _loadVisitedLocations() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      // 30ì¼ ì´ë‚´ ë°©ë¬¸ ê¸°ë¡ ê°€ì ¸ì˜¤ê¸° (ì˜¬ë°”ë¥¸ ì»¬ë ‰ì…˜ ê²½ë¡œ ì‚¬ìš©)
      final thirtyDaysAgo = DateTime.now().subtract(const Duration(days: 30));
      
      final visitedTiles = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .collection('visited_tiles')
          .where('lastVisitTime', isGreaterThanOrEqualTo: Timestamp.fromDate(thirtyDaysAgo))
          .get();

      final visitedPositions = <LatLng>[];
      
      for (final doc in visitedTiles.docs) {
        final tileId = doc.id;
        // íƒ€ì¼ IDì—ì„œ ì¢Œí‘œ ì¶”ì¶œ
        final position = _extractPositionFromTileId(tileId);
        if (position != null) {
          visitedPositions.add(position);
        }
      }

      print('ê³¼ê±° ë°©ë¬¸ ìœ„ì¹˜ ê°œìˆ˜: ${visitedPositions.length}');
      
      // íšŒìƒ‰ ì˜ì—­ ìƒì„±
      final grayPolygons = OSMFogService.createGrayAreas(visitedPositions);

      if (mounted) {
        setState(() {
          _grayPolygons = grayPolygons;
        });
      }

    } catch (e) {
      debugPrint('ë°©ë¬¸ ìœ„ì¹˜ ë¡œë“œ ì‹¤íŒ¨: $e');
    }
  }

  // íƒ€ì¼ IDì—ì„œ ì¢Œí‘œ ì¶”ì¶œí•˜ëŠ” í—¬í¼ ë©”ì„œë“œ
  LatLng? _extractPositionFromTileId(String tileId) {
    try {
      // âœ… TileUtilsì˜ í‘œì¤€ ë©”ì„œë“œ ì‚¬ìš© (ì¤‘ë³µ ë¡œì§ ì œê±°)
      return TileUtils.getKm1TileCenter(tileId);
    } catch (e) {
      debugPrint('íƒ€ì¼ ID ë³€í™˜ ì‹¤íŒ¨: $tileId - $e');
      return null;
    }
  }

  Future<void> _updateCurrentAddress() async {
    if (_currentPosition == null) return;
    
    try {
      final address = await NominatimService.reverseGeocode(_currentPosition!);
      if (mounted) {
        setState(() {
          _currentAddress = address;
        });
      }

      // ìƒìœ„ ìœ„ì ¯ì— ì£¼ì†Œ ì „ë‹¬
      widget.onAddressChanged?.call(address);
    } catch (e) {
      if (mounted) {
        setState(() {
          _currentAddress = 'ì£¼ì†Œ ë³€í™˜ ì‹¤íŒ¨';
        });
      }
    }
  }

  // ğŸš€ Firestore ê¸°ë°˜ ì‹¤ì‹œê°„ ë§ˆì»¤ ë¡œë“œ (ì œê±°ë¨ - _setupPostStreamListenerë¡œ ëŒ€ì²´)

  Future<void> _loadPosts({bool forceRefresh = false}) async {
    if (_currentPosition == null) return;
    
    // ë¡œë”© ìƒíƒœëŠ” ì§§ê²Œë§Œ í‘œì‹œ
    if (forceRefresh) {
      setState(() {
        _isLoading = true;
      });
    }

    try {
      // ìƒˆë¡œìš´ êµ¬ì¡°: MarkerServiceì—ì„œ ì§ì ‘ ë§ˆì»¤ ì¡°íšŒ
      await _updatePostsBasedOnFogLevel();
        
        if (mounted) {
          setState(() {
            _isLoading = false;
        });
      }
    } catch (e) {
      setState(() {
        _errorMessage = 'ë§ˆì»¤ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: $e';
        _isLoading = false;
      });
    }
  }


  // ë§µ ìƒíƒœ ì—…ë°ì´íŠ¸ (í´ëŸ¬ìŠ¤í„°ë§ìš©)
  void _updateMapState() {
    if (_mapController != null) {
      final camera = _mapController!.camera;
      _mapCenter = camera.center;
      _mapZoom = camera.zoom;
      
      // í™”ë©´ í¬ê¸° ì—…ë°ì´íŠ¸ (MediaQuery ì‚¬ìš©)
      final size = MediaQuery.of(context).size;
      _lastMapSize = size;
      
      // í´ëŸ¬ìŠ¤í„°ë§ ë””ë°”ìš´ìŠ¤ íƒ€ì´ë¨¸
      _clusterDebounceTimer?.cancel();
      _clusterDebounceTimer = Timer(const Duration(milliseconds: 32), _rebuildClusters);
    }
  }

  // ğŸš€ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸: ì§€ë„ ì´ë™ ê°ì§€ ë° ë§ˆì»¤ ìƒˆë¡œê³ ì¹¨
  void _onMapMoved(MapEvent event) {
    // ë§µ ìƒíƒœ ì—…ë°ì´íŠ¸
    _updateMapState();
    
    if (event is MapEventMove || event is MapEventMoveStart) {
      // ì§€ë„ ì´ë™ ì¤‘ì´ë©´ íƒ€ì´ë¨¸ ë¦¬ì…‹ (ë””ë°”ìš´ìŠ¤ ì‹œê°„ ì¦ê°€)
      _mapMoveTimer?.cancel();
      _mapMoveTimer = Timer(const Duration(milliseconds: 500), () {
        _handleMapMoveComplete();
      });
      
      // ì‹¤ì‹œê°„ìœ¼ë¡œ ìˆ˜ë ¹ ê°€ëŠ¥ ë§ˆì»¤ ê°œìˆ˜ ì—…ë°ì´íŠ¸
      _updateReceivablePosts();
    }
  }

  // ì§€ë„ ì´ë™ ì™„ë£Œ í›„ ì²˜ë¦¬
  Future<void> _handleMapMoveComplete() async {
    if (_isUpdatingPosts) return; // ì´ë¯¸ ì—…ë°ì´íŠ¸ ì¤‘ì´ë©´ ìŠ¤í‚µ
    
    final currentCenter = _mapController?.camera.center;
    if (currentCenter == null) return;
    
    // ìºì‹œ í‚¤ ê¸°ë°˜ ìŠ¤í‚µ ë¡œì§
    final newCacheKey = _generateCacheKeyForLocation(currentCenter);
    if (newCacheKey == _lastCacheKey) {
      print('ğŸ”„ ë™ì¼ íƒ€ì¼ ìœ„ì¹˜ - ë§ˆì»¤ ì—…ë°ì´íŠ¸ ìŠ¤í‚µ');
      return;
    }
    
    // ì´ì „ ìœ„ì¹˜ì™€ ê±°ë¦¬ ê³„ì‚° (200m ì´ìƒ ì´ë™í–ˆì„ ë•Œë§Œ ì—…ë°ì´íŠ¸)
    if (_lastMapCenter != null) {
      final distance = _calculateDistance(_lastMapCenter!, currentCenter);
      if (distance < 200) return; // 200m ë¯¸ë§Œ ì´ë™ì€ ë¬´ì‹œ
      
      // ğŸ”¥ ìœ„ì¹˜ ì´ë™ ì‹œ 1ë‹¨ê³„ íƒ€ì¼ ìºì‹œ ì´ˆê¸°í™” (ì¤‘ìš”í•œ ìˆ˜ì •!)
      print('ğŸ§¹ ì§€ë„ ì´ë™ ê°ì§€ - 1ë‹¨ê³„ íƒ€ì¼ ìºì‹œ ì´ˆê¸°í™”');
      _clearFogLevel1Cache();
    }
    
    _isUpdatingPosts = true;
    
    try {
      print('ğŸ”„ ì§€ë„ ì´ë™ ê°ì§€ - ë§ˆì»¤ ì—…ë°ì´íŠ¸ ì‹œì‘');
        
        // í˜„ì¬ ìœ„ì¹˜ëŠ” GPSì—ì„œë§Œ ì—…ë°ì´íŠ¸ (ë§µì„¼í„°ë¡œ ì—…ë°ì´íŠ¸í•˜ì§€ ì•ŠìŒ)
        
      // ğŸš€ ì„œë²„ APIë¥¼ í†µí•œ ë§ˆì»¤ ì¡°íšŒ
        await _updatePostsBasedOnFogLevel();
        
        // ìˆ˜ë ¹ ê°€ëŠ¥ í¬ìŠ¤íŠ¸ ê°œìˆ˜ ì—…ë°ì´íŠ¸
        _updateReceivablePosts();
        
        // ë§ˆì§€ë§‰ ìƒíƒœ ì €ì¥
        _lastMapCenter = currentCenter;
      _lastCacheKey = newCacheKey;
      
    } catch (e) {
      print('ì§€ë„ ì´ë™ í›„ í¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: $e');
    } finally {
      _isUpdatingPosts = false;
    }
  }
  
  // ìœ„ì¹˜ ê¸°ë°˜ ìºì‹œ í‚¤ ìƒì„± - ì£¼ë³€ íƒ€ì¼ë“¤ë„ ê³ ë ¤í•˜ì—¬ ê°œì„ 
  String _generateCacheKeyForLocation(LatLng location) {
    // í˜„ì¬ ìœ„ì¹˜ì˜ 1km íƒ€ì¼ ID
    final currentTileId = TileUtils.getKm1TileId(location.latitude, location.longitude);
    
    // ì£¼ë³€ 1ë‹¨ê³„ íƒ€ì¼ë“¤ë„ ìºì‹œ í‚¤ì— í¬í•¨ (ì •í™•ë„ í–¥ìƒ)
    final surroundingTiles = TileUtils.getKm1SurroundingTiles(location.latitude, location.longitude);
    final tileIds = surroundingTiles.take(9).toList(); // 3x3 ê·¸ë¦¬ë“œë§Œ ê³ ë ¤
    
    // íƒ€ì¼ IDë“¤ì„ ì •ë ¬í•˜ì—¬ ì¼ê´€ëœ ìºì‹œ í‚¤ ìƒì„±
    tileIds.sort();
    final tileKey = tileIds.join('_');
    
    return 'fog_${currentTileId}_${tileKey.hashCode}';
  }

  // í˜„ì¬ ìœ„ì¹˜ì˜ í¬ê·¸ë ˆë²¨ 1ë‹¨ê³„ íƒ€ì¼ë“¤ ê³„ì‚° - ê°œì„ ëœ ë¡œì§
  Future<Set<String>> _getCurrentFogLevel1Tiles(LatLng center) async {
    try {
      // ğŸ”¥ ìºì‹œ ë§Œë£Œ í™•ì¸ ë° ì´ˆê¸°í™”
      _checkAndClearExpiredFogLevel1Cache();
      
      final surroundingTiles = TileUtils.getKm1SurroundingTiles(center.latitude, center.longitude);
      final fogLevel1Tiles = <String>{};
      
      print('ğŸ” í¬ê·¸ë ˆë²¨ 1+2ë‹¨ê³„ íƒ€ì¼ ê³„ì‚° ì‹œì‘ (ê°œì„ ëœ ë¡œì§):');
      print('  - ì¤‘ì‹¬ ìœ„ì¹˜: ${center.latitude}, ${center.longitude}');
      print('  - ì£¼ë³€ íƒ€ì¼ ê°œìˆ˜: ${surroundingTiles.length}');
      print('  - ë¡œì»¬ ìºì‹œ íƒ€ì¼ ê°œìˆ˜: ${_currentFogLevel1TileIds.length}');
      
      for (final tileId in surroundingTiles) {
        final tileCenter = TileUtils.getKm1TileCenter(tileId);
        final distToCenterKm = _calculateDistance(center, tileCenter);
        
        // íƒ€ì¼ì˜ ì‹¤ì œ í¬ê¸° ê³„ì‚° (ì •í™•í•œ ë°˜ì§€ë¦„)
        final tileBounds = TileUtils.getKm1TileBounds(tileId);
        final tileRadiusKm = _calculateTileRadiusKm(tileBounds);
        
        print('  - íƒ€ì¼ $tileId: ì¤‘ì‹¬ê±°ë¦¬ ${distToCenterKm.toStringAsFixed(2)}km, íƒ€ì¼ë°˜ì§€ë¦„ ${tileRadiusKm.toStringAsFixed(2)}km');
        
        // ğŸ”¥ ê°œì„ ëœ ë¡œì§: ê±°ë¦¬ ê¸°ë°˜ ìš°ì„  íŒë‹¨, ë¡œì»¬ ìºì‹œëŠ” ë³´ì¡°ì ìœ¼ë¡œë§Œ ì‚¬ìš©
        if (distToCenterKm <= (1.0 + tileRadiusKm)) {
          // 1km ë°˜ì§€ë¦„ê³¼ íƒ€ì¼ì´ ê²¹ì¹¨ - ë¬´ì¡°ê±´ 1ë‹¨ê³„
          fogLevel1Tiles.add(tileId);
          print('    âœ… 1km+íƒ€ì¼ë°˜ì§€ë¦„ ì´ë‚´ - í¬ê·¸ë ˆë²¨ 1 ì¶”ê°€');
          
          // ë¡œì»¬ ìºì‹œì—ë„ ì¶”ê°€ (ë‹¤ìŒ ê³„ì‚° ì‹œ ë¹ ë¥¸ ì ‘ê·¼ìš©)
          if (!_currentFogLevel1TileIds.contains(tileId)) {
            _currentFogLevel1TileIds.add(tileId);
          }
        } else {
          // 1km ë°–ì€ ë°©ë¬¸ ê¸°ë¡ í™•ì¸ (í¬ê·¸ë ˆë²¨ 2)
          final fogLevel = await VisitTileService.getFogLevelForTile(tileId);
          print('    ğŸ” 1km+íƒ€ì¼ë°˜ì§€ë¦„ ë°– - í¬ê·¸ë ˆë²¨: $fogLevel');
          if (fogLevel == FogLevel.clear || fogLevel == FogLevel.gray) {
            fogLevel1Tiles.add(tileId);
            print('    âœ… í¬ê·¸ë ˆë²¨ 1+2 ì˜ì—­ - ë§ˆì»¤ í‘œì‹œ ê°€ëŠ¥');
            
            // ë°©ë¬¸ ê¸°ë¡ì´ ìˆëŠ” íƒ€ì¼ë„ ë¡œì»¬ ìºì‹œì— ì¶”ê°€
            if (!_currentFogLevel1TileIds.contains(tileId)) {
              _currentFogLevel1TileIds.add(tileId);
            }
          } else {
            // í¬ê·¸ë ˆë²¨ 3 ì´ìƒì´ë©´ ë¡œì»¬ ìºì‹œì—ì„œ ì œê±° (ì •í™•ì„± í–¥ìƒ)
            if (_currentFogLevel1TileIds.contains(tileId)) {
              _currentFogLevel1TileIds.remove(tileId);
              print('    ğŸ—‘ï¸ ë¡œì»¬ ìºì‹œì—ì„œ ì œê±°ë¨ (í¬ê·¸ë ˆë²¨ 3 ì´ìƒ): $tileId');
            }
          }
        }
      }
      
      print('âœ… ìµœì¢… í¬ê·¸ë ˆë²¨ 1+2 íƒ€ì¼ ê°œìˆ˜: ${fogLevel1Tiles.length}');
      
      // ğŸ”¥ ìºì‹œ ê³„ì‚° ì™„ë£Œ ì‹œ íƒ€ì„ìŠ¤íƒ¬í”„ ì—…ë°ì´íŠ¸
      _updateFogLevel1CacheTimestamp();
      
      return fogLevel1Tiles;
    } catch (e) {
      print('í¬ê·¸ë ˆë²¨ 1+2ë‹¨ê³„ íƒ€ì¼ ê³„ì‚° ì‹¤íŒ¨: $e');
      return {};
    }
  }

  /// íƒ€ì¼ ë°˜ì§€ë¦„ ê³„ì‚° (km) - ì •í™•í•œ ê³„ì‚°
  double _calculateTileRadiusKm(Map<String, double> bounds) {
    // íƒ€ì¼ì˜ ì¤‘ì‹¬ì 
    final center = LatLng(
      (bounds['minLat']! + bounds['maxLat']!) / 2, 
      (bounds['minLng']! + bounds['maxLng']!) / 2,
    );
    
    // íƒ€ì¼ì˜ ë„¤ ëª¨ì„œë¦¬ ì¤‘ ê°€ì¥ ë¨¼ ê±°ë¦¬ ê³„ì‚°
    final corners = [
      LatLng(bounds['minLat']!, bounds['minLng']!), // ë‚¨ì„œìª½
      LatLng(bounds['minLat']!, bounds['maxLng']!), // ë‚¨ë™ìª½
      LatLng(bounds['maxLat']!, bounds['minLng']!), // ë¶ì„œìª½
      LatLng(bounds['maxLat']!, bounds['maxLng']!), // ë¶ë™ìª½
    ];
    
    double maxDistance = 0;
    for (final corner in corners) {
      final distance = _calculateDistance(center, corner);
      if (distance > maxDistance) {
        maxDistance = distance;
      }
    }
    
    return maxDistance;
  }

  /// íƒ€ì¼ ë°˜ëŒ€ê°ì„  ì ˆë°˜ ê¸¸ì´ ê³„ì‚° (km) - ê¸°ì¡´ í˜¸í™˜ì„± ìœ ì§€
  double _approxTileHalfDiagonalKm(Map<String, double> bounds) {
    final center = LatLng(
      (bounds['minLat']! + bounds['maxLat']!) / 2, 
      (bounds['minLng']! + bounds['maxLng']!) / 2
    );
    final corner = LatLng(bounds['maxLat']!, bounds['maxLng']!);
    final diag = _calculateDistance(center, corner) * 2; // centerâ†’corner*2 â‰ˆ ì „ì²´ ëŒ€ê°ì„ 
    return diag / 2.0;
  }

  /// ë°©ê¸ˆ ë°©ë¬¸í•œ íƒ€ì¼ì„ ë¡œì»¬ì— ì¦‰ì‹œ ë°˜ì˜
  void _setLevel1TileLocally(String tileId) {
    setState(() {
      _currentFogLevel1TileIds.add(tileId);
    });
    print('ğŸš€ íƒ€ì¼ $tileId ë¡œì»¬ì— ì¦‰ì‹œ ë°˜ì˜ë¨');
  }


  /// 1ë‹¨ê³„ íƒ€ì¼ ìºì‹œ ì´ˆê¸°í™” (ì§€ë„ ì´ë™ ì‹œ í˜¸ì¶œ)
  void _clearFogLevel1Cache() {
    setState(() {
      _currentFogLevel1TileIds.clear();
      _fogLevel1CacheTimestamp = null;
    });
    print('ğŸ§¹ 1ë‹¨ê³„ íƒ€ì¼ ìºì‹œ ì´ˆê¸°í™” ì™„ë£Œ');
  }

  /// 1ë‹¨ê³„ íƒ€ì¼ ìºì‹œ ë§Œë£Œ í™•ì¸ ë° ì´ˆê¸°í™”
  void _checkAndClearExpiredFogLevel1Cache() {
    if (_fogLevel1CacheTimestamp != null) {
      final now = DateTime.now();
      if (now.difference(_fogLevel1CacheTimestamp!) > _fogLevel1CacheExpiry) {
        print('â° 1ë‹¨ê³„ íƒ€ì¼ ìºì‹œ ë§Œë£Œ - ìë™ ì´ˆê¸°í™”');
        _clearFogLevel1Cache();
      }
    }
  }

  /// 1ë‹¨ê³„ íƒ€ì¼ ìºì‹œ ì—…ë°ì´íŠ¸ (íƒ€ì„ìŠ¤íƒ¬í”„ í¬í•¨)
  void _updateFogLevel1CacheTimestamp() {
    _fogLevel1CacheTimestamp = DateTime.now();
  }

  // ë‘ íƒ€ì¼ ì„¸íŠ¸ê°€ ê°™ì€ì§€ ë¹„êµ
  bool _areTileSetsEqual(Set<String> set1, Set<String> set2) {
    if (set1.length != set2.length) return false;
    return set1.every((tile) => set2.contains(tile));
  }

  // GPS í™œì„±í™” ìš”ì²­ ë‹¤ì´ì–¼ë¡œê·¸
  void _showLocationPermissionDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Row(
            children: [
              Icon(Icons.location_on, color: Colors.blue),
              SizedBox(width: 8),
              Text('ìœ„ì¹˜ ì„œë¹„ìŠ¤ í•„ìš”'),
            ],
          ),
          content: const Text(
            'ì§€ë„ì—ì„œ ë§ˆì»¤ë¥¼ ë³´ë ¤ë©´ GPSë¥¼ í™œì„±í™”í•´ì£¼ì„¸ìš”.\n\n'
            'ì„¤ì • > ê°œì¸ì •ë³´ ë³´í˜¸ ë° ë³´ì•ˆ > ìœ„ì¹˜ ì„œë¹„ìŠ¤ì—ì„œ\n'
            'ì•±ì˜ ìœ„ì¹˜ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.',
            style: TextStyle(fontSize: 16),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
                _getCurrentLocation(); // ìœ„ì¹˜ ë‹¤ì‹œ ìš”ì²­
              },
              child: const Text('ë‹¤ì‹œ ì‹œë„'),
            ),
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text('ë‚˜ì¤‘ì—'),
            ),
          ],
        );
      },
    );
  }

  // ğŸš€ ì„œë²„ APIë¥¼ í†µí•œ ë§ˆì»¤ ì¡°íšŒ
  Future<void> _updatePostsBasedOnFogLevel() async {
    // Mock ëª¨ë“œì—ì„œëŠ” Mock ìœ„ì¹˜ ì‚¬ìš©, ì•„ë‹ˆë©´ ì‹¤ì œ GPS ìœ„ì¹˜ ì‚¬ìš©
    LatLng? effectivePosition;
    if (_isMockModeEnabled && _mockPosition != null) {
      effectivePosition = _mockPosition;
      print('ğŸ­ Mock ëª¨ë“œ - Mock ìœ„ì¹˜ ì‚¬ìš©: ${_mockPosition!.latitude}, ${_mockPosition!.longitude}');
    } else {
      effectivePosition = _currentPosition;
      print('ğŸ“ GPS ëª¨ë“œ - ì‹¤ì œ ìœ„ì¹˜ ì‚¬ìš©: ${_currentPosition?.latitude}, ${_currentPosition?.longitude}');
    }
    
    // ìœ„ì¹˜ê°€ ì—†ìœ¼ë©´ GPS í™œì„±í™” ìš”ì²­
    if (effectivePosition == null) {
      _showLocationPermissionDialog();
      return;
    }
    
    final centers = <LatLng>[];
    centers.add(effectivePosition);
    print('ğŸ“ ê¸°ì¤€ ìœ„ì¹˜: ${effectivePosition.latitude}, ${effectivePosition.longitude}');
      
      // ì§‘ì£¼ì†Œ ì¶”ê°€
      if (_homeLocation != null) {
      centers.add(_homeLocation!);
      print('ğŸ  ì§‘ì£¼ì†Œ: ${_homeLocation!.latitude}, ${_homeLocation!.longitude}');
      }
      
      // ë“±ë¡í•œ ì¼í„°ë“¤ ì¶”ê°€
    centers.addAll(_workLocations);
      for (int i = 0; i < _workLocations.length; i++) {
      print('ğŸ¢ ì¼í„°${i + 1}: ${_workLocations[i].latitude}, ${_workLocations[i].longitude}');
    }
    
    print('ğŸ¯ ì´ ${centers.length}ê°œì˜ ê¸°ì¤€ì ì—ì„œ ë§ˆì»¤ ê²€ìƒ‰');

    try {
      print('ğŸ” _updatePostsBasedOnFogLevel í˜¸ì¶œë¨');

      // 2. í•„í„° ì„¤ì •
      final filters = <String, dynamic>{
        'showCouponsOnly': _showCouponsOnly,
        'myPostsOnly': _showMyPostsOnly,
        'minReward': _minReward,
        'showUrgentOnly': _showUrgentOnly,
        'showVerifiedOnly': _showVerifiedOnly, // ì¸ì¦ í•„í„° ì¶”ê°€
        'showUnverifiedOnly': _showUnverifiedOnly, // ë¯¸ì¸ì¦ í•„í„° ì¶”ê°€
      };
      
      print('');
      print('ğŸŸ¢ğŸŸ¢ğŸŸ¢ ========== í•„í„° ìƒíƒœ í™•ì¸ ========== ğŸŸ¢ğŸŸ¢ğŸŸ¢');
      print('ğŸŸ¢ _showMyPostsOnly: $_showMyPostsOnly');
      print('ğŸŸ¢ _showVerifiedOnly: $_showVerifiedOnly');
      print('ğŸŸ¢ _showUnverifiedOnly: $_showUnverifiedOnly');
      print('ğŸŸ¢ _showCouponsOnly: $_showCouponsOnly');
      print('ğŸŸ¢ _showUrgentOnly: $_showUrgentOnly');
      print('ğŸŸ¢ ì „ë‹¬ë˜ëŠ” filters ë§µ: $filters');
      print('ğŸŸ¢ğŸŸ¢ğŸŸ¢ ====================================== ğŸŸ¢ğŸŸ¢ğŸŸ¢');
      print('');

      // 3. ì„œë²„ì—ì„œ ì¼ë°˜ í¬ìŠ¤íŠ¸ì™€ ìŠˆí¼í¬ìŠ¤íŠ¸ë¥¼ ë³‘ë ¬ë¡œ ì¡°íšŒ
      final primaryCenter = centers.first; // ì²« ë²ˆì§¸ ì¤‘ì‹¬ì  ì‚¬ìš©
      final additionalCenters = centers.skip(1).toList(); // ë‚˜ë¨¸ì§€ëŠ” ì¶”ê°€ ì¤‘ì‹¬ì 
      
      // ì‚¬ìš©ì íƒ€ì…ì— ë”°ë¥¸ ê±°ë¦¬ ê³„ì‚°
      final normalRadiusKm = MarkerService.getMarkerDisplayRadius(_userType, false) / 1000.0;
      final superRadiusKm = MarkerService.getMarkerDisplayRadius(_userType, true) / 1000.0;
      
      print('ğŸ” ì„œë²„ í˜¸ì¶œ ì‹œì‘:');
      print('  - ì£¼ ì¤‘ì‹¬ì : ${primaryCenter.latitude}, ${primaryCenter.longitude}');
      print('  - ì¶”ê°€ ì¤‘ì‹¬ì : ${additionalCenters.length}ê°œ');
      print('  - ì¼ë°˜ í¬ìŠ¤íŠ¸ ë°˜ê²½: ${normalRadiusKm}km');
      print('  - ìŠˆí¼í¬ìŠ¤íŠ¸ ë°˜ê²½: ${superRadiusKm}km');
      
      final futures = await Future.wait([
        // ì¼ë°˜ í¬ìŠ¤íŠ¸ ì¡°íšŒ
        MapMarkerService.getMarkers(
          location: primaryCenter,
          radiusInKm: normalRadiusKm, // ì‚¬ìš©ì íƒ€ì…ì— ë”°ë¥¸ ê±°ë¦¬
          additionalCenters: additionalCenters,
          filters: filters,
          pageSize: 1000, // âœ… ì œí•œ ì¦ê°€ (ì˜ì—­ ë‚´ì—ì„œë§Œ ì¡°íšŒí•˜ë¯€ë¡œ)
        ),
        // ìŠˆí¼ë§ˆì»¤ ì¡°íšŒ
        MapMarkerService.getSuperMarkers(
          location: primaryCenter,
          radiusInKm: superRadiusKm, // ìŠˆí¼í¬ìŠ¤íŠ¸ëŠ” í•­ìƒ 5km
          additionalCenters: additionalCenters,
          filters: filters, // âœ… í•„í„° ì „ë‹¬
          pageSize: 500, // âœ… ì œí•œ ì¦ê°€
        ),
      ]);

      final normalMarkers = futures[0] as List<MapMarkerData>;
      final superMarkers = futures[1] as List<MapMarkerData>;
      
      print('ğŸ“ ì„œë²„ ì‘ë‹µ:');
      print('  - ì¼ë°˜ ë§ˆì»¤: ${normalMarkers.length}ê°œ');
      print('  - ìŠˆí¼ë§ˆì»¤: ${superMarkers.length}ê°œ');
      
      // ğŸ”¥ Fail-open: ë§ˆì»¤ê°€ ì—†ìœ¼ë©´ ê²½ê³  ë©”ì‹œì§€
      if (normalMarkers.isEmpty && superMarkers.isEmpty) {
        print('âš ï¸ ë§ˆì»¤ê°€ ì—†ìŠµë‹ˆë‹¤! ê°€ëŠ¥í•œ ì›ì¸:');
        print('  - ìœ„ì¹˜ ê¶Œí•œ ë¬¸ì œ');
        print('  - ì„œë²„ í•„í„°ê°€ ë„ˆë¬´ ê°•í•¨');
        print('  - í¬ê·¸ë ˆë²¨ 1 íƒ€ì¼ì´ ì—†ìŒ');
        print('  - Firestore ë°ì´í„° ì—†ìŒ');
      }

      // 4. ëª¨ë“  ë§ˆì»¤ë¥¼ í•©ì¹˜ê³  ì¤‘ë³µ ì œê±°
      final allMarkers = <MapMarkerData>[];
      final seenMarkerIds = <String>{};
      
      // ì¼ë°˜ í¬ìŠ¤íŠ¸ ì¶”ê°€
      for (final marker in normalMarkers) {
        if (!seenMarkerIds.contains(marker.id)) {
          allMarkers.add(marker);
          seenMarkerIds.add(marker.id);
        }
      }
      
      // ìŠˆí¼ë§ˆì»¤ ì¶”ê°€
      for (final marker in superMarkers) {
        if (!seenMarkerIds.contains(marker.id)) {
          allMarkers.add(marker);
          seenMarkerIds.add(marker.id);
        }
      }

      // 5. MarkerDataë¥¼ MarkerModelë¡œ ë³€í™˜
      final uniqueMarkers = allMarkers.map((markerData) => 
        MapMarkerService.convertToMarkerModel(markerData)
      ).toList();

      // 6. ì´ë¯¸ ìˆ˜ë ¹í•œ í¬ìŠ¤íŠ¸ í•„í„°ë§
      final currentUser = FirebaseAuth.instance.currentUser;
      Set<String> collectedPostIds = {};
      
      if (currentUser != null) {
        try {
          print('ğŸ” ì´ë¯¸ ìˆ˜ë ¹í•œ í¬ìŠ¤íŠ¸ í™•ì¸ ì¤‘...');
          final collectedSnapshot = await FirebaseFirestore.instance
              .collection('post_collections')
              .where('userId', isEqualTo: currentUser.uid)
              .get();
          
          collectedPostIds = collectedSnapshot.docs
              .map((doc) => doc.data()['postId'] as String)
              .toSet();
          
          print('ğŸ“¦ ì´ë¯¸ ìˆ˜ë ¹í•œ í¬ìŠ¤íŠ¸: ${collectedPostIds.length}ê°œ');
        } catch (e) {
          print('âŒ ìˆ˜ë ¹ ê¸°ë¡ ì¡°íšŒ ì‹¤íŒ¨: $e');
        }
      }
      
      // ì´ë¯¸ ìˆ˜ë ¹í•œ í¬ìŠ¤íŠ¸ì˜ ë§ˆì»¤ ì œê±°
      final filteredMarkers = uniqueMarkers.where((marker) {
        final isCollected = collectedPostIds.contains(marker.postId);
        if (isCollected) {
          print('ğŸš« ì´ë¯¸ ìˆ˜ë ¹í•œ í¬ìŠ¤íŠ¸ì˜ ë§ˆì»¤ ì œê±°: ${marker.title} (postId: ${marker.postId})');
        }
        return !isCollected;
      }).toList();
      
      print('âœ… í•„í„°ë§ í›„ ë§ˆì»¤: ${filteredMarkers.length}ê°œ (${uniqueMarkers.length - filteredMarkers.length}ê°œ ì œê±°ë¨)');

      // 7. í¬ìŠ¤íŠ¸ ì •ë³´ë„ í•¨ê»˜ ê°€ì ¸ì˜¤ê¸°
      final postIds = filteredMarkers.map((marker) => marker.postId).toSet().toList();
      final posts = <PostModel>[];
      
      if (postIds.isNotEmpty) {
        try {
          final postSnapshots = await FirebaseFirestore.instance
              .collection('posts')
              .where('postId', whereIn: postIds)
              .get();
          
          for (final doc in postSnapshots.docs) {
            try {
              final post = PostModel.fromFirestore(doc);
              posts.add(post);
            } catch (e) {
              print('í¬ìŠ¤íŠ¸ íŒŒì‹± ì˜¤ë¥˜: $e');
            }
          }
          
          print('ğŸ“„ í¬ìŠ¤íŠ¸ ì •ë³´ ì¡°íšŒ ì™„ë£Œ: ${posts.length}ê°œ');
        } catch (e) {
          print('âŒ í¬ìŠ¤íŠ¸ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: $e');
        }
      }

      setState(() {
        _markers = filteredMarkers;
        _posts = posts; // í¬ìŠ¤íŠ¸ ì •ë³´ë„ ì—…ë°ì´íŠ¸
        _isLoading = false;
        print('âœ… _updatePostsBasedOnFogLevel: ì´ ${_markers.length}ê°œì˜ ê³ ìœ  ë§ˆì»¤, ${_posts.length}ê°œì˜ í¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ë¨');
        _updateMarkers(); // ë§ˆì»¤ ì—…ë°ì´íŠ¸ í›„ ì§€ë„ ë§ˆì»¤ë„ ì—…ë°ì´íŠ¸
      });

    } catch (e, stackTrace) {
      print('âŒ _updatePostsBasedOnFogLevel ì˜¤ë¥˜: $e');
      print('ğŸ“š ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤: $stackTrace');
      
      // ğŸ”¥ Fail-open: ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ê¸°ë³¸ ë§ˆì»¤ë¼ë„ í‘œì‹œ
      print('ğŸ”„ ì—ëŸ¬ ë°œìƒ - ê¸°ë³¸ ë§ˆì»¤ í‘œì‹œ ì‹œë„');
      
      setState(() {
        _isLoading = false;
        _errorMessage = 'ë§ˆì»¤ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: $e';
        
        // ì—ëŸ¬ ë°œìƒ ì‹œ ë¹ˆ ë§ˆì»¤ ë¦¬ìŠ¤íŠ¸ë¡œ ì„¤ì • (ë¬´í•œ ë¡œë”© ë°©ì§€)
        _markers = [];
        _updateMarkers();
      });
    }
  }

  // í¬ê·¸ë ˆë²¨ì— ë”°ë¥¸ ë§ˆì»¤ í•„í„°ë§
  Future<void> _filterPostsByFogLevel(Set<String> fogLevel1Tiles) async {
    try {
      // ìƒˆë¡œìš´ êµ¬ì¡°: MarkerServiceì—ì„œ ì§ì ‘ ë§ˆì»¤ ì¡°íšŒ
      await _updatePostsBasedOnFogLevel();
      
    } catch (e) {
      print('ë§ˆì»¤ í•„í„°ë§ ì‹¤íŒ¨: $e');
    }
  }

  /// í˜„ì¬ìœ„ì¹˜, ì§‘, ì¼í„° ì£¼ë³€ì—ì„œ ë¡±í”„ë ˆìŠ¤ ê°€ëŠ¥í•œì§€ í™•ì¸
  bool _canLongPressAtLocation(LatLng point) {
    final maxRadius = MarkerService.getMarkerDisplayRadius(_userType, false);
    
    // Mock ëª¨ë“œì—ì„œëŠ” Mock ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ, ì•„ë‹ˆë©´ ì‹¤ì œ GPS ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í™•ì¸
    LatLng? referencePosition;
    if (_isMockModeEnabled && _mockPosition != null) {
      referencePosition = _mockPosition;
    } else {
      referencePosition = _currentPosition;
    }
    
    // ê¸°ì¤€ ìœ„ì¹˜ ì£¼ë³€ í™•ì¸
    if (referencePosition != null) {
      final distanceToCurrent = MarkerService.calculateDistance(
        LatLng(referencePosition.latitude, referencePosition.longitude),
        point,
      );
      if (distanceToCurrent <= maxRadius) {
        return true;
      }
    }
    
    // ì§‘ ì£¼ë³€ í™•ì¸
    if (_homeLocation != null) {
      final distanceToHome = MarkerService.calculateDistance(
        LatLng(_homeLocation!.latitude, _homeLocation!.longitude),
        point,
      );
      if (distanceToHome <= maxRadius) {
        return true;
      }
    }
    
    // ì¼í„° ì£¼ë³€ í™•ì¸
    for (final workLocation in _workLocations) {
      final distanceToWork = MarkerService.calculateDistance(
        LatLng(workLocation.latitude, workLocation.longitude),
